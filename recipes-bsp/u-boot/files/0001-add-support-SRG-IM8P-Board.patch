From 6709ed4a5fd6ed46aa66d6a37d197a51280a1f3e Mon Sep 17 00:00:00 2001
From: KunYi <kunyi.chen@gmail.com>
Date: Mon, 12 Apr 2021 17:47:50 +0800
Subject: [PATCH] add support SRG-IM8P Board

to support AAEON SRG-IM8P Board and some feature
include the below
  squashfs
  distro boot command
  save env. into emmc
---
 arch/arm/dts/Makefile                |    1 +
 arch/arm/dts/srg-im8p.dts            |  639 +++++++++
 arch/arm/mach-imx/imx8m/Kconfig      |    9 +-
 arch/arm/mach-imx/mmc_env.c          |    3 +
 board/aaeon/srg-im8p/Kconfig         |   19 +
 board/aaeon/srg-im8p/MAINTAINERS     |    6 +
 board/aaeon/srg-im8p/Makefile        |   13 +
 board/aaeon/srg-im8p/README.md       |   60 +
 board/aaeon/srg-im8p/lpddr4_timing.c | 1849 ++++++++++++++++++++++++++
 board/aaeon/srg-im8p/mmc.c           |   51 +
 board/aaeon/srg-im8p/spl.c           |  281 ++++
 board/aaeon/srg-im8p/srg-im8p.c      |  361 +++++
 board/freescale/common/mmc.c         |    6 +-
 cmd/Kconfig                          |   11 +-
 cmd/Makefile                         |    1 +
 cmd/bootm.c                          |    9 +
 cmd/mmc.c                            |   54 +-
 cmd/sqfs.c                           |   42 +
 configs/imx8mp_evk_defconfig         |    5 +-
 configs/srg-im8p_defconfig           |  181 +++
 drivers/mmc/fsl_esdhc_imx.c          |    3 +
 drivers/mmc/mmc.c                    |    7 +-
 drivers/tpm/tpm_tis.h                |    4 +-
 fs/Kconfig                           |    2 +
 fs/Makefile                          |    2 +
 fs/fs.c                              |   25 +
 fs/squashfs/Kconfig                  |   11 +
 fs/squashfs/Makefile                 |    7 +
 fs/squashfs/sqfs.c                   | 1723 ++++++++++++++++++++++++
 fs/squashfs/sqfs_decompressor.c      |  155 +++
 fs/squashfs/sqfs_decompressor.h      |   61 +
 fs/squashfs/sqfs_dir.c               |   93 ++
 fs/squashfs/sqfs_filesystem.h        |  310 +++++
 fs/squashfs/sqfs_inode.c             |  162 +++
 fs/squashfs/sqfs_utils.h             |   49 +
 include/configs/imx8mp_evk.h         |   37 +-
 include/configs/srg-im8p.h           |  315 +++++
 include/fs.h                         |    1 +
 include/mmc.h                        |   23 +
 include/squashfs.h                   |   24 +
 include/u-boot/zlib.h                |   32 +
 lib/Kconfig                          |    6 +
 lib/zlib/inftrees.c                  |   19 +-
 lib/zlib/uncompr.c                   |   97 ++
 lib/zlib/zlib.c                      |    3 +
 45 files changed, 6736 insertions(+), 36 deletions(-)
 create mode 100644 arch/arm/dts/srg-im8p.dts
 create mode 100644 board/aaeon/srg-im8p/Kconfig
 create mode 100644 board/aaeon/srg-im8p/MAINTAINERS
 create mode 100644 board/aaeon/srg-im8p/Makefile
 create mode 100644 board/aaeon/srg-im8p/README.md
 create mode 100644 board/aaeon/srg-im8p/lpddr4_timing.c
 create mode 100644 board/aaeon/srg-im8p/mmc.c
 create mode 100644 board/aaeon/srg-im8p/spl.c
 create mode 100644 board/aaeon/srg-im8p/srg-im8p.c
 create mode 100644 cmd/sqfs.c
 create mode 100644 configs/srg-im8p_defconfig
 create mode 100644 fs/squashfs/Kconfig
 create mode 100644 fs/squashfs/Makefile
 create mode 100644 fs/squashfs/sqfs.c
 create mode 100644 fs/squashfs/sqfs_decompressor.c
 create mode 100644 fs/squashfs/sqfs_decompressor.h
 create mode 100644 fs/squashfs/sqfs_dir.c
 create mode 100644 fs/squashfs/sqfs_filesystem.h
 create mode 100644 fs/squashfs/sqfs_inode.c
 create mode 100644 fs/squashfs/sqfs_utils.h
 create mode 100644 include/configs/srg-im8p.h
 create mode 100644 include/squashfs.h
 create mode 100644 lib/zlib/uncompr.c

diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 47cd054d84..4d6eec6491 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -784,6 +784,7 @@ dtb-$(CONFIG_ARCH_IMX8) += \
 	imx8-giedi.dtb
 
 dtb-$(CONFIG_ARCH_IMX8M) += \
+	srg-im8p.dtb \
 	imx8mm-evk.dtb \
 	imx8mm-evk-qca-wifi.dtb \
 	imx8mm-ddr4-evk.dtb \
diff --git a/arch/arm/dts/srg-im8p.dts b/arch/arm/dts/srg-im8p.dts
new file mode 100644
index 0000000000..8f8f341524
--- /dev/null
+++ b/arch/arm/dts/srg-im8p.dts
@@ -0,0 +1,639 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2021 UWINGS
+ * Copyright 2019 NXP
+ */
+
+/dts-v1/;
+
+#include "imx8mp.dtsi"
+
+/ {
+	model = "AAEON SRG-IM8P IoT Gateway";
+	compatible = "aaeon,srg-im8p", "fsl,imx8mp-evk", "fsl,imx8mp";
+
+	chosen {
+		bootargs = "console=ttymxc1,115200 earlycon=ec_imx6q,0x30890000,115200";
+		stdout-path = &uart2;
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0xC0000000>;
+	};
+
+	reg_usb1_host_vbus: regulator-usb1-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb1_host_vbus";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usb1_vbus>;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&gpio1 05 GPIO_ACTIVE_HIGH>;
+		enable-active-low;
+		regulator-always-on;
+	};
+
+	reg_usb2_host_vbus: regulator-usb2-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb2_host_vbus";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usb2_vbus>;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&gpio1 06 GPIO_ACTIVE_HIGH>;
+		enable-active-low;
+		regulator-always-on;
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
+		regulator-name = "VSD_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio1 06 GPIO_ACTIVE_HIGH>;
+		enable-active-low;
+		startup-delay-us = <100>;
+		off-on-delay-us = <12000>;
+	};
+
+	dsi_host: dsi-host {
+		compatible = "samsung,sec-mipi-dsi";
+		status = "okay";
+	};
+
+	rm67191_panel {
+		compatible = "raydium,rm67191";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_mipi_dsi_en>;
+		reset-gpio = <&gpio1 8 GPIO_ACTIVE_LOW>;
+		dsi-lanes = <4>;
+		video-mode = <2>;	/* 0: burst mode
+					 * 1: non-burst mode with sync event
+					 * 2: non-burst mode with sync pulse
+					 */
+		panel-width-mm = <68>;
+		panel-height-mm = <121>;
+		status = "okay";
+
+		port {
+			rm67191_from_dsim: endpoint {
+				remote-endpoint = <&dsim_to_rm67191>;
+			};
+		};
+	};
+	/* TPM */
+	soft-spi {
+		compatible = "spi-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ecspi2_gpio>;
+		cs-gpios = <&gpio5 13 0>;
+		gpio-sck = <&gpio5 10 0>;
+		gpio-mosi = <&gpio5 11 0>;
+		gpio-miso = <&gpio5 12 0>;
+		spi-delay-us = <1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		tpm2:npct750@0 {
+			reg = <0>;
+			compatible = "tis,tpm2-spi";
+			spi-max-frequency = <1000000>;
+			gpio-reset = <&gpio1 15 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&eqos {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_eqos>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy0>;
+	status = "okay";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+			eee-broken-1000t;
+		};
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy1>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+			eee-broken-1000t;
+		};
+	};
+};
+
+&flexspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexspi0>;
+	status = "okay";
+
+	flash0: mt25qu256aba@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <80000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+	};
+};
+
+&i2c1 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	pinctrl-1 = <&pinctrl_i2c1_gpio>;
+	scl-gpios = <&gpio5 14 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&gpio5 15 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	pmic: pca9450@25 {
+		reg = <0x25>;
+		compatible = "nxp,pca9450c";
+		/* PMIC PCA9450 PMIC_nINT GPIO1_IO3 */
+		pinctrl-0 = <&pinctrl_pmic>;
+		gpio_intr = <&gpio1 3 GPIO_ACTIVE_LOW>;
+
+		regulators {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			pca9450,pmic-buck2-uses-i2c-dvs;
+			/* Run/Standby voltage */
+			pca9450,pmic-buck2-dvs-voltage = <950000>, <850000>;
+
+			buck1_reg: regulator@0 {
+				reg = <0>;
+				regulator-compatible = "buck1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck2_reg: regulator@1 {
+				reg = <1>;
+				regulator-compatible = "buck2";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck4_reg: regulator@3 {
+				reg = <3>;
+				regulator-compatible = "buck4";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck5_reg: regulator@4 {
+				reg = <4>;
+				regulator-compatible = "buck5";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6_reg: regulator@5 {
+				reg = <5>;
+				regulator-compatible = "buck6";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1_reg: regulator@6 {
+				reg = <6>;
+				regulator-compatible = "ldo1";
+				regulator-min-microvolt = <1600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2_reg: regulator@7 {
+				reg = <7>;
+				regulator-compatible = "ldo2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3_reg: regulator@8 {
+				reg = <8>;
+				regulator-compatible = "ldo3";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4_reg: regulator@9 {
+				reg = <9>;
+				regulator-compatible = "ldo4";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5_reg: regulator@10 {
+				reg = <10>;
+				regulator-compatible = "ldo5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	pinctrl-1 = <&pinctrl_i2c2_gpio>;
+	scl-gpios = <&gpio5 16 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&gpio5 17 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	adv_bridge: adv7535@3d {
+		compatible = "adi,adv7533";
+		reg = <0x3d>;
+		adi,addr-cec = <0x3c>;
+		adi,dsi-lanes = <4>;
+		status = "okay";
+
+		port {
+			adv7535_from_dsim: endpoint {
+				remote-endpoint = <&dsim_to_adv7535>;
+			};
+		};
+	};
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	pinctrl-1 = <&pinctrl_i2c3_gpio>;
+	scl-gpios = <&gpio5 18 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&gpio5 19 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&lcdif1 {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	port@1 {
+		dsim_to_adv7535: endpoint {
+			remote-endpoint = <&adv7535_from_dsim>;
+		};
+	};
+
+	port@2 {
+		dsim_to_rm67191: endpoint {
+			remote-endpoint = <&rm67191_from_dsim>;
+		};
+	};
+};
+
+&snvs_pwrkey {
+	status = "okay";
+};
+
+&uart2 {
+	/* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&usb3_phy0 {
+	status = "okay";
+};
+
+&usb_dwc3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb3_phy1 {
+	status = "okay";
+};
+
+&usb_dwc3_1 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+
+	pinctrl_eqos: eqosgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC	0x3
+			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO	0x3
+			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0	0x91
+			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1	0x91
+			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2	0x91
+			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3	0x91
+			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x91
+			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x1f
+			/* Reset for Eth0 */
+			MX8MP_IOMUXC_SAI2_RXC__GPIO4_IO22		0x19
+		>;
+	};
+
+	pinctrl_fec: fecgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_RXD2__ENET1_MDC		0x3
+			MX8MP_IOMUXC_SAI1_RXD3__ENET1_MDIO		0x3
+			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x91
+			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x91
+			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x91
+			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x91
+			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x91
+			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x1f
+			/* Reset for Eth1 */
+			MX8MP_IOMUXC_SAI1_RXD0__GPIO4_IO02		0x19
+		>;
+	};
+
+	pinctrl_flexspi0: flexspi0grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_ALE__FLEXSPI_A_SCLK		0x1c2
+			MX8MP_IOMUXC_NAND_CE0_B__FLEXSPI_A_SS0_B	0x82
+			MX8MP_IOMUXC_NAND_DATA00__FLEXSPI_A_DATA00	0x82
+			MX8MP_IOMUXC_NAND_DATA01__FLEXSPI_A_DATA01	0x82
+			MX8MP_IOMUXC_NAND_DATA02__FLEXSPI_A_DATA02	0x82
+			MX8MP_IOMUXC_NAND_DATA03__FLEXSPI_A_DATA03	0x82
+		>;
+	};
+
+	pinctrl_gpio_led: gpioledgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_READY_B__GPIO3_IO16	0x19
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C1_SCL__I2C1_SCL		0x400001c3
+			MX8MP_IOMUXC_I2C1_SDA__I2C1_SDA		0x400001c3
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C2_SCL__I2C2_SCL			0x400001c3
+			MX8MP_IOMUXC_I2C2_SDA__I2C2_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C3_SCL__I2C3_SCL			0x400001c3
+			MX8MP_IOMUXC_I2C3_SDA__I2C3_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_i2c1_gpio: i2c1grp-gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C1_SCL__GPIO5_IO14        	0x1c3
+			MX8MP_IOMUXC_I2C1_SDA__GPIO5_IO15        	0x1c3
+		>;
+	};
+
+	pinctrl_i2c2_gpio: i2c2grp-gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C2_SCL__GPIO5_IO16        	0x1c3
+			MX8MP_IOMUXC_I2C2_SDA__GPIO5_IO17        	0x1c3
+		>;
+	};
+
+	pinctrl_i2c3_gpio: i2c3grp-gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C3_SCL__GPIO5_IO18        	0x1c3
+			MX8MP_IOMUXC_I2C3_SDA__GPIO5_IO19        	0x1c3
+		>;
+	};
+
+	pinctrl_mipi_dsi_en: mipi_dsi_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO08__GPIO1_IO08	0x16
+		>;
+	};
+
+	pinctrl_pmic: pmicirq {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x41
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmc {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x41
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART2_RXD__UART2_DCE_RX	0x49
+			MX8MP_IOMUXC_UART2_TXD__UART2_DCE_TX	0x49
+		>;
+	};
+
+	pinctrl_usb1_vbus: usb1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO05__GPIO1_IO05	0x19
+		>;
+	};
+
+	pinctrl_usb2_vbus: usb2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO06__GPIO1_IO06	0x19
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x190
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d0
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d0
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d0
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d0
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2grp-100mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x194
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d4
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d4
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d4
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d4
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d4
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2grp-200mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x196
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d6
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d6
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d6
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d6
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d6
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2grp-gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CD_B__GPIO2_IO12	0x1c4
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x190
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d0
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d0
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d0
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d0
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d0
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d0
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d0
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d0
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d0
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x190
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3grp-100mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x194
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d4
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d4
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d4
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d4
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d4
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d4
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d4
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d4
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d4
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x194
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3grp-200mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x196
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d6
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d6
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d6
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d6
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d6
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d6
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d6
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d6
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d6
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x196
+		>;
+	};
+
+	pinctrl_wdog: wdoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO02__WDOG1_WDOG_B	0xc6
+		>;
+	};
+
+	pinctrl_ecspi2_gpio: ecspi2_gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SCLK__GPIO5_IO10	0x146
+			MX8MP_IOMUXC_ECSPI2_MOSI__GPIO5_IO11	0x146
+			MX8MP_IOMUXC_ECSPI2_MISO__GPIO5_IO12	0x146
+			MX8MP_IOMUXC_ECSPI2_SS0__GPIO5_IO13	0x146
+			MX8MP_IOMUXC_GPIO1_IO15__GPIO1_IO15	0x046
+		>;
+	};
+};
diff --git a/arch/arm/mach-imx/imx8m/Kconfig b/arch/arm/mach-imx/imx8m/Kconfig
index 41c68a49a3..3f103e3028 100644
--- a/arch/arm/mach-imx/imx8m/Kconfig
+++ b/arch/arm/mach-imx/imx8m/Kconfig
@@ -30,7 +30,7 @@ config SYS_SOC
 config SECONDARY_BOOT_SECTOR_OFFSET
 	hex "SD/MMC sector offset used for ROM secondary boot"
 	default 0x0
-	depends on IMX8MQ || IMX8MM
+	depends on IMX8MQ || IMX8MM || IMX8MP
 	help
 	  Set the sector offset to non-zero value in SPL used for
 	  secondary boot image. This value should be same as the
@@ -154,8 +154,15 @@ config TARGET_VERDIN_IMX8MM
        select SUPPORT_SPL
        select IMX8M_LPDDR4
 
+config TARGET_SRG_IM8P
+       bool "Support AAEON SRG-IM8P Gateway"
+       select IMX8MP
+       select SUPPORT_SPL
+       select IMX8M_LPDDR4
+
 endchoice
 
+source "board/aaeon/srg-im8p/Kconfig"
 source "board/freescale/imx8mq_evk/Kconfig"
 source "board/freescale/imx8mq_val/Kconfig"
 source "board/freescale/imx8mm_ab2/Kconfig"
diff --git a/arch/arm/mach-imx/mmc_env.c b/arch/arm/mach-imx/mmc_env.c
index 22d8daa107..b2b771bbf5 100644
--- a/arch/arm/mach-imx/mmc_env.c
+++ b/arch/arm/mach-imx/mmc_env.c
@@ -24,6 +24,9 @@ int mmc_get_env_dev(void)
 	/* If not boot from sd/mmc, use default value */
 	if ((boot_type != BOOT_TYPE_SD) && (boot_type != BOOT_TYPE_MMC))
 		return env_get_ulong("mmcdev", 10, CONFIG_SYS_MMC_ENV_DEV);
+	/* fixed env. on emmc device */
+	if (env_get_yesno("env_on_emmc"))
+		return CONFIG_SYS_MMC_ENV_DEV;
 
 	return board_mmc_get_env_dev(devno);
 }
diff --git a/board/aaeon/srg-im8p/Kconfig b/board/aaeon/srg-im8p/Kconfig
new file mode 100644
index 0000000000..7e66de18b2
--- /dev/null
+++ b/board/aaeon/srg-im8p/Kconfig
@@ -0,0 +1,19 @@
+if TARGET_SRG_IM8P
+
+config SYS_BOARD
+	default "srg-im8p"
+
+config SYS_VENDOR
+	default "aaeon"
+
+config SYS_CONFIG_NAME
+	default "srg-im8p"
+
+config SYS_BOARD_NAME
+	string "for board name"
+	default "SRG-IM8P"
+
+config SYS_BOARD_REV
+	string "for board revision"
+	default "EVK"
+endif
diff --git a/board/aaeon/srg-im8p/MAINTAINERS b/board/aaeon/srg-im8p/MAINTAINERS
new file mode 100644
index 0000000000..c9f98d867c
--- /dev/null
+++ b/board/aaeon/srg-im8p/MAINTAINERS
@@ -0,0 +1,6 @@
+AAEON SRG-IM8P IoT Gateway
+M:	KunYi Chen <kunyi.chen@gmail.com>
+S:	Maintained
+F:	board/aaeon/srg-im8p/
+F:	include/configs/srg-im8p.h
+F:	configs/srg-im8p_defconfig
diff --git a/board/aaeon/srg-im8p/Makefile b/board/aaeon/srg-im8p/Makefile
new file mode 100644
index 0000000000..3f3d966d35
--- /dev/null
+++ b/board/aaeon/srg-im8p/Makefile
@@ -0,0 +1,13 @@
+#
+# Copyright 2021 UWINGS
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y += srg-im8p.o
+obj-y += mmc.o
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+obj-y += lpddr4_timing.o
+endif
diff --git a/board/aaeon/srg-im8p/README.md b/board/aaeon/srg-im8p/README.md
new file mode 100644
index 0000000000..d8a8cb7111
--- /dev/null
+++ b/board/aaeon/srg-im8p/README.md
@@ -0,0 +1,60 @@
+U-Boot for the AAEON SRG-IM8P IoT Gateway
+
+Quick Start
+===========
+* Build the ARM Trusted firmware binary
+* Get ddr and hdmi fimware
+* Build U-Boot
+* Boot
+
+Get and Build the ARM Trusted firmware
+======================================
+Get ATF from: https://source.codeaurora.org/external/imx/imx-atf
+
+branch: lf_v2.4
+```
+$ make PLAT=imx8mp bl31 # without OP-TEE
+or
+$ make PLAT=imx8mp SPD=opteed bl31 # with OP-TEE
+
+$ cp build/imx8mp/release/bl31.bin $(builddir)
+```
+
+Get the ddr and hdmi firmware
+=============================
+```
+$ wget https://www.nxp.com/lgfiles/NMG/MAD/YOCTO/firmware-imx-8.11.bin
+$ chmod +x firmware-imx-8.11.bin
+$ ./firmware-imx-8.11.bin
+$ cp firmware-imx-8.11/firmware/hdmi/cadence/signed_hdmi_imx8m.bin $(builddir)
+
+```
+
+Build U-Boot
+============
+```
+$ export CROSS_COMPILE=<aarch64 toolchain path>
+$ make distclean
+$ make srg-mx8p_defconfig
+$ make all -j8
+```
+
+Burn the flash.bin to MicroSD card offset 32KB
+==============================================
+```
+dd if=flash.bin of=/dev/sd[x] bs=1K seek=32 conv=sync
+$sudo dd if=u-boot.itb of=/dev/sd[x] bs=1K seek=384 conv=sync
+```
+
+Boot
+====
+Set Boot switch SW5: 0011 to boot from Micro SD.
+
+Get and Build OP-TEE OS
+=======================
+Get OP-TEE OS from: https://source.codeaurora.org/external/imx/imx-optee-os
+branch: lf-5.10.y_1.0.0
+```
+$make ARCH=arm PLATFORM=imx PLATFORM_FLAVOR=mx8mpevk
+$aarch64-linux-gnu-objcopy -O binary tee.elf tee.bin
+```
diff --git a/board/aaeon/srg-im8p/lpddr4_timing.c b/board/aaeon/srg-im8p/lpddr4_timing.c
new file mode 100644
index 0000000000..97413d31e7
--- /dev/null
+++ b/board/aaeon/srg-im8p/lpddr4_timing.c
@@ -0,0 +1,1849 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Generated code from MX8M_DDR_tool
+ *
+ */
+
+#include <linux/kernel.h>
+#include <asm/arch/ddr.h>
+
+struct dram_cfg_param ddr_ddrc_cfg[] = {
+	/** Initialize DDRC registers **/
+	{ 0x3d400304, 0x1 },
+	{ 0x3d400030, 0x1 },
+	{ 0x3d400000, 0xa1080020 },
+	{ 0x3d400020, 0x1223 },
+	{ 0x3d400024, 0x16e3600 },
+	{ 0x3d400064, 0x5b00d2 },
+	{ 0x3d400070, 0x61027f10 },
+	{ 0x3d400074, 0x7b0 },
+	{ 0x3d4000d0, 0xc00305ba },
+	{ 0x3d4000d4, 0x940000 },
+	{ 0x3d4000dc, 0xd4002d },
+	{ 0x3d4000e0, 0x330000 },
+	{ 0x3d4000e8, 0x660048 },
+	{ 0x3d4000ec, 0x160048 },
+	{ 0x3d400100, 0x191e1920 },
+	{ 0x3d400104, 0x60630 },
+	{ 0x3d40010c, 0xb0b000 },
+	{ 0x3d400110, 0xe04080e },
+	{ 0x3d400114, 0x2040c0c },
+	{ 0x3d400118, 0x1010007 },
+	{ 0x3d40011c, 0x401 },
+	{ 0x3d400130, 0x20600 },
+	{ 0x3d400134, 0xc100002 },
+	{ 0x3d400138, 0xd8 },
+	{ 0x3d400144, 0x96004b },
+	{ 0x3d400180, 0x2ee0017 },
+	{ 0x3d400184, 0x2605b8e },
+	{ 0x3d400188, 0x0 },
+	{ 0x3d400190, 0x497820a },
+	{ 0x3d400194, 0x80303 },
+	{ 0x3d4001b4, 0x170a },
+	{ 0x3d4001a0, 0xe0400018 },
+	{ 0x3d4001a4, 0xdf00e4 },
+	{ 0x3d4001a8, 0x80000000 },
+	{ 0x3d4001b0, 0x11 },
+	{ 0x3d4001c0, 0x1 },
+	{ 0x3d4001c4, 0x1 },
+	{ 0x3d4000f4, 0xc99 },
+	{ 0x3d400108, 0x70e1617 },
+	{ 0x3d400200, 0x1f },
+	{ 0x3d40020c, 0x0 },
+	{ 0x3d400210, 0x1f1f },
+	{ 0x3d400204, 0x80808 },
+	{ 0x3d400214, 0x7070707 },
+	{ 0x3d400218, 0x7070707 },
+	{ 0x3d40021c, 0xf0f },
+	{ 0x3d400250, 0x1705 },
+	{ 0x3d400254, 0x2c },
+	{ 0x3d40025c, 0x4000030 },
+	{ 0x3d400264, 0x900093e7 },
+	{ 0x3d40026c, 0x2005574 },
+	{ 0x3d400400, 0x111 },
+	{ 0x3d400404, 0x72ff },
+	{ 0x3d400408, 0x72ff },
+	{ 0x3d400494, 0x2100e07 },
+	{ 0x3d400498, 0x620096 },
+	{ 0x3d40049c, 0x1100e07 },
+	{ 0x3d4004a0, 0xc8012c },
+	{ 0x3d402020, 0x1021 },
+	{ 0x3d402024, 0x30d400 },
+	{ 0x3d402050, 0x20d000 },
+	{ 0x3d402064, 0xc001c },
+	{ 0x3d4020dc, 0x840000 },
+	{ 0x3d4020e0, 0x330000 },
+	{ 0x3d4020e8, 0x660048 },
+	{ 0x3d4020ec, 0x160048 },
+	{ 0x3d402100, 0xa040305 },
+	{ 0x3d402104, 0x30407 },
+	{ 0x3d402108, 0x203060b },
+	{ 0x3d40210c, 0x505000 },
+	{ 0x3d402110, 0x2040202 },
+	{ 0x3d402114, 0x2030202 },
+	{ 0x3d402118, 0x1010004 },
+	{ 0x3d40211c, 0x301 },
+	{ 0x3d402130, 0x20300 },
+	{ 0x3d402134, 0xa100002 },
+	{ 0x3d402138, 0x1d },
+	{ 0x3d402144, 0x14000a },
+	{ 0x3d402180, 0x640004 },
+	{ 0x3d402190, 0x3818200 },
+	{ 0x3d402194, 0x80303 },
+	{ 0x3d4021b4, 0x100 },
+	{ 0x3d4020f4, 0xc99 },
+	{ 0x3d403020, 0x1021 },
+	{ 0x3d403024, 0xc3500 },
+	{ 0x3d403050, 0x20d000 },
+	{ 0x3d403064, 0x30007 },
+	{ 0x3d4030dc, 0x840000 },
+	{ 0x3d4030e0, 0x330000 },
+	{ 0x3d4030e8, 0x660048 },
+	{ 0x3d4030ec, 0x160048 },
+	{ 0x3d403100, 0xa010102 },
+	{ 0x3d403104, 0x30404 },
+	{ 0x3d403108, 0x203060b },
+	{ 0x3d40310c, 0x505000 },
+	{ 0x3d403110, 0x2040202 },
+	{ 0x3d403114, 0x2030202 },
+	{ 0x3d403118, 0x1010004 },
+	{ 0x3d40311c, 0x301 },
+	{ 0x3d403130, 0x20300 },
+	{ 0x3d403134, 0xa100002 },
+	{ 0x3d403138, 0x8 },
+	{ 0x3d403144, 0x50003 },
+	{ 0x3d403180, 0x190004 },
+	{ 0x3d403190, 0x3818200 },
+	{ 0x3d403194, 0x80303 },
+	{ 0x3d4031b4, 0x100 },
+	{ 0x3d4030f4, 0xc99 },
+	{ 0x3d400028, 0x0 },
+};
+
+/* PHY Initialize Configuration */
+struct dram_cfg_param ddr_ddrphy_cfg[] = {
+	{ 0x100a0, 0x0 },
+	{ 0x100a1, 0x1 },
+	{ 0x100a2, 0x2 },
+	{ 0x100a3, 0x3 },
+	{ 0x100a4, 0x4 },
+	{ 0x100a5, 0x5 },
+	{ 0x100a6, 0x6 },
+	{ 0x100a7, 0x7 },
+	{ 0x110a0, 0x0 },
+	{ 0x110a1, 0x1 },
+	{ 0x110a2, 0x3 },
+	{ 0x110a3, 0x4 },
+	{ 0x110a4, 0x5 },
+	{ 0x110a5, 0x2 },
+	{ 0x110a6, 0x7 },
+	{ 0x110a7, 0x6 },
+	{ 0x120a0, 0x0 },
+	{ 0x120a1, 0x1 },
+	{ 0x120a2, 0x3 },
+	{ 0x120a3, 0x2 },
+	{ 0x120a4, 0x5 },
+	{ 0x120a5, 0x4 },
+	{ 0x120a6, 0x7 },
+	{ 0x120a7, 0x6 },
+	{ 0x130a0, 0x0 },
+	{ 0x130a1, 0x1 },
+	{ 0x130a2, 0x2 },
+	{ 0x130a3, 0x3 },
+	{ 0x130a4, 0x4 },
+	{ 0x130a5, 0x5 },
+	{ 0x130a6, 0x6 },
+	{ 0x130a7, 0x7 },
+	{ 0x1005f, 0x1ff },
+	{ 0x1015f, 0x1ff },
+	{ 0x1105f, 0x1ff },
+	{ 0x1115f, 0x1ff },
+	{ 0x1205f, 0x1ff },
+	{ 0x1215f, 0x1ff },
+	{ 0x1305f, 0x1ff },
+	{ 0x1315f, 0x1ff },
+	{ 0x11005f, 0x1ff },
+	{ 0x11015f, 0x1ff },
+	{ 0x11105f, 0x1ff },
+	{ 0x11115f, 0x1ff },
+	{ 0x11205f, 0x1ff },
+	{ 0x11215f, 0x1ff },
+	{ 0x11305f, 0x1ff },
+	{ 0x11315f, 0x1ff },
+	{ 0x21005f, 0x1ff },
+	{ 0x21015f, 0x1ff },
+	{ 0x21105f, 0x1ff },
+	{ 0x21115f, 0x1ff },
+	{ 0x21205f, 0x1ff },
+	{ 0x21215f, 0x1ff },
+	{ 0x21305f, 0x1ff },
+	{ 0x21315f, 0x1ff },
+	{ 0x55, 0x1ff },
+	{ 0x1055, 0x1ff },
+	{ 0x2055, 0x1ff },
+	{ 0x3055, 0x1ff },
+	{ 0x4055, 0x1ff },
+	{ 0x5055, 0x1ff },
+	{ 0x6055, 0x1ff },
+	{ 0x7055, 0x1ff },
+	{ 0x8055, 0x1ff },
+	{ 0x9055, 0x1ff },
+	{ 0x200c5, 0x19 },
+	{ 0x1200c5, 0x7 },
+	{ 0x2200c5, 0x7 },
+	{ 0x2002e, 0x2 },
+	{ 0x12002e, 0x2 },
+	{ 0x22002e, 0x2 },
+	{ 0x90204, 0x0 },
+	{ 0x190204, 0x0 },
+	{ 0x290204, 0x0 },
+	{ 0x20024, 0x1e3 },
+	{ 0x2003a, 0x2 },
+	{ 0x120024, 0x1e3 },
+	{ 0x2003a, 0x2 },
+	{ 0x220024, 0x1e3 },
+	{ 0x2003a, 0x2 },
+	{ 0x20056, 0x3 },
+	{ 0x120056, 0x3 },
+	{ 0x220056, 0x3 },
+	{ 0x1004d, 0xe00 },
+	{ 0x1014d, 0xe00 },
+	{ 0x1104d, 0xe00 },
+	{ 0x1114d, 0xe00 },
+	{ 0x1204d, 0xe00 },
+	{ 0x1214d, 0xe00 },
+	{ 0x1304d, 0xe00 },
+	{ 0x1314d, 0xe00 },
+	{ 0x11004d, 0xe00 },
+	{ 0x11014d, 0xe00 },
+	{ 0x11104d, 0xe00 },
+	{ 0x11114d, 0xe00 },
+	{ 0x11204d, 0xe00 },
+	{ 0x11214d, 0xe00 },
+	{ 0x11304d, 0xe00 },
+	{ 0x11314d, 0xe00 },
+	{ 0x21004d, 0xe00 },
+	{ 0x21014d, 0xe00 },
+	{ 0x21104d, 0xe00 },
+	{ 0x21114d, 0xe00 },
+	{ 0x21204d, 0xe00 },
+	{ 0x21214d, 0xe00 },
+	{ 0x21304d, 0xe00 },
+	{ 0x21314d, 0xe00 },
+	{ 0x10049, 0xeba },
+	{ 0x10149, 0xeba },
+	{ 0x11049, 0xeba },
+	{ 0x11149, 0xeba },
+	{ 0x12049, 0xeba },
+	{ 0x12149, 0xeba },
+	{ 0x13049, 0xeba },
+	{ 0x13149, 0xeba },
+	{ 0x110049, 0xeba },
+	{ 0x110149, 0xeba },
+	{ 0x111049, 0xeba },
+	{ 0x111149, 0xeba },
+	{ 0x112049, 0xeba },
+	{ 0x112149, 0xeba },
+	{ 0x113049, 0xeba },
+	{ 0x113149, 0xeba },
+	{ 0x210049, 0xeba },
+	{ 0x210149, 0xeba },
+	{ 0x211049, 0xeba },
+	{ 0x211149, 0xeba },
+	{ 0x212049, 0xeba },
+	{ 0x212149, 0xeba },
+	{ 0x213049, 0xeba },
+	{ 0x213149, 0xeba },
+	{ 0x43, 0x63 },
+	{ 0x1043, 0x63 },
+	{ 0x2043, 0x63 },
+	{ 0x3043, 0x63 },
+	{ 0x4043, 0x63 },
+	{ 0x5043, 0x63 },
+	{ 0x6043, 0x63 },
+	{ 0x7043, 0x63 },
+	{ 0x8043, 0x63 },
+	{ 0x9043, 0x63 },
+	{ 0x20018, 0x3 },
+	{ 0x20075, 0x4 },
+	{ 0x20050, 0x0 },
+	{ 0x20008, 0x2ee },
+	{ 0x120008, 0x64 },
+	{ 0x220008, 0x19 },
+	{ 0x20088, 0x9 },
+	{ 0x200b2, 0x104 },
+	{ 0x10043, 0x5a1 },
+	{ 0x10143, 0x5a1 },
+	{ 0x11043, 0x5a1 },
+	{ 0x11143, 0x5a1 },
+	{ 0x12043, 0x5a1 },
+	{ 0x12143, 0x5a1 },
+	{ 0x13043, 0x5a1 },
+	{ 0x13143, 0x5a1 },
+	{ 0x1200b2, 0x104 },
+	{ 0x110043, 0x5a1 },
+	{ 0x110143, 0x5a1 },
+	{ 0x111043, 0x5a1 },
+	{ 0x111143, 0x5a1 },
+	{ 0x112043, 0x5a1 },
+	{ 0x112143, 0x5a1 },
+	{ 0x113043, 0x5a1 },
+	{ 0x113143, 0x5a1 },
+	{ 0x2200b2, 0x104 },
+	{ 0x210043, 0x5a1 },
+	{ 0x210143, 0x5a1 },
+	{ 0x211043, 0x5a1 },
+	{ 0x211143, 0x5a1 },
+	{ 0x212043, 0x5a1 },
+	{ 0x212143, 0x5a1 },
+	{ 0x213043, 0x5a1 },
+	{ 0x213143, 0x5a1 },
+	{ 0x200fa, 0x1 },
+	{ 0x1200fa, 0x1 },
+	{ 0x2200fa, 0x1 },
+	{ 0x20019, 0x1 },
+	{ 0x120019, 0x1 },
+	{ 0x220019, 0x1 },
+	{ 0x200f0, 0x660 },
+	{ 0x200f1, 0x0 },
+	{ 0x200f2, 0x4444 },
+	{ 0x200f3, 0x8888 },
+	{ 0x200f4, 0x5665 },
+	{ 0x200f5, 0x0 },
+	{ 0x200f6, 0x0 },
+	{ 0x200f7, 0xf000 },
+	{ 0x20025, 0x0 },
+	{ 0x2002d, 0x0 },
+	{ 0x12002d, 0x0 },
+	{ 0x22002d, 0x0 },
+	{ 0x2007d, 0x212 },
+	{ 0x12007d, 0x212 },
+	{ 0x22007d, 0x212 },
+	{ 0x2007c, 0x61 },
+	{ 0x12007c, 0x61 },
+	{ 0x22007c, 0x61 },
+	{ 0x1004a, 0x500 },
+	{ 0x1104a, 0x500 },
+	{ 0x1204a, 0x500 },
+	{ 0x1304a, 0x500 },
+	{ 0x2002c, 0x0 },
+};
+
+/* ddr phy trained csr */
+struct dram_cfg_param ddr_ddrphy_trained_csr[] = {
+	{ 0x200b2, 0x0 },
+	{ 0x1200b2, 0x0 },
+	{ 0x2200b2, 0x0 },
+	{ 0x200cb, 0x0 },
+	{ 0x10043, 0x0 },
+	{ 0x110043, 0x0 },
+	{ 0x210043, 0x0 },
+	{ 0x10143, 0x0 },
+	{ 0x110143, 0x0 },
+	{ 0x210143, 0x0 },
+	{ 0x11043, 0x0 },
+	{ 0x111043, 0x0 },
+	{ 0x211043, 0x0 },
+	{ 0x11143, 0x0 },
+	{ 0x111143, 0x0 },
+	{ 0x211143, 0x0 },
+	{ 0x12043, 0x0 },
+	{ 0x112043, 0x0 },
+	{ 0x212043, 0x0 },
+	{ 0x12143, 0x0 },
+	{ 0x112143, 0x0 },
+	{ 0x212143, 0x0 },
+	{ 0x13043, 0x0 },
+	{ 0x113043, 0x0 },
+	{ 0x213043, 0x0 },
+	{ 0x13143, 0x0 },
+	{ 0x113143, 0x0 },
+	{ 0x213143, 0x0 },
+	{ 0x80, 0x0 },
+	{ 0x100080, 0x0 },
+	{ 0x200080, 0x0 },
+	{ 0x1080, 0x0 },
+	{ 0x101080, 0x0 },
+	{ 0x201080, 0x0 },
+	{ 0x2080, 0x0 },
+	{ 0x102080, 0x0 },
+	{ 0x202080, 0x0 },
+	{ 0x3080, 0x0 },
+	{ 0x103080, 0x0 },
+	{ 0x203080, 0x0 },
+	{ 0x4080, 0x0 },
+	{ 0x104080, 0x0 },
+	{ 0x204080, 0x0 },
+	{ 0x5080, 0x0 },
+	{ 0x105080, 0x0 },
+	{ 0x205080, 0x0 },
+	{ 0x6080, 0x0 },
+	{ 0x106080, 0x0 },
+	{ 0x206080, 0x0 },
+	{ 0x7080, 0x0 },
+	{ 0x107080, 0x0 },
+	{ 0x207080, 0x0 },
+	{ 0x8080, 0x0 },
+	{ 0x108080, 0x0 },
+	{ 0x208080, 0x0 },
+	{ 0x9080, 0x0 },
+	{ 0x109080, 0x0 },
+	{ 0x209080, 0x0 },
+	{ 0x10080, 0x0 },
+	{ 0x110080, 0x0 },
+	{ 0x210080, 0x0 },
+	{ 0x10180, 0x0 },
+	{ 0x110180, 0x0 },
+	{ 0x210180, 0x0 },
+	{ 0x11080, 0x0 },
+	{ 0x111080, 0x0 },
+	{ 0x211080, 0x0 },
+	{ 0x11180, 0x0 },
+	{ 0x111180, 0x0 },
+	{ 0x211180, 0x0 },
+	{ 0x12080, 0x0 },
+	{ 0x112080, 0x0 },
+	{ 0x212080, 0x0 },
+	{ 0x12180, 0x0 },
+	{ 0x112180, 0x0 },
+	{ 0x212180, 0x0 },
+	{ 0x13080, 0x0 },
+	{ 0x113080, 0x0 },
+	{ 0x213080, 0x0 },
+	{ 0x13180, 0x0 },
+	{ 0x113180, 0x0 },
+	{ 0x213180, 0x0 },
+	{ 0x10081, 0x0 },
+	{ 0x110081, 0x0 },
+	{ 0x210081, 0x0 },
+	{ 0x10181, 0x0 },
+	{ 0x110181, 0x0 },
+	{ 0x210181, 0x0 },
+	{ 0x11081, 0x0 },
+	{ 0x111081, 0x0 },
+	{ 0x211081, 0x0 },
+	{ 0x11181, 0x0 },
+	{ 0x111181, 0x0 },
+	{ 0x211181, 0x0 },
+	{ 0x12081, 0x0 },
+	{ 0x112081, 0x0 },
+	{ 0x212081, 0x0 },
+	{ 0x12181, 0x0 },
+	{ 0x112181, 0x0 },
+	{ 0x212181, 0x0 },
+	{ 0x13081, 0x0 },
+	{ 0x113081, 0x0 },
+	{ 0x213081, 0x0 },
+	{ 0x13181, 0x0 },
+	{ 0x113181, 0x0 },
+	{ 0x213181, 0x0 },
+	{ 0x100d0, 0x0 },
+	{ 0x1100d0, 0x0 },
+	{ 0x2100d0, 0x0 },
+	{ 0x101d0, 0x0 },
+	{ 0x1101d0, 0x0 },
+	{ 0x2101d0, 0x0 },
+	{ 0x110d0, 0x0 },
+	{ 0x1110d0, 0x0 },
+	{ 0x2110d0, 0x0 },
+	{ 0x111d0, 0x0 },
+	{ 0x1111d0, 0x0 },
+	{ 0x2111d0, 0x0 },
+	{ 0x120d0, 0x0 },
+	{ 0x1120d0, 0x0 },
+	{ 0x2120d0, 0x0 },
+	{ 0x121d0, 0x0 },
+	{ 0x1121d0, 0x0 },
+	{ 0x2121d0, 0x0 },
+	{ 0x130d0, 0x0 },
+	{ 0x1130d0, 0x0 },
+	{ 0x2130d0, 0x0 },
+	{ 0x131d0, 0x0 },
+	{ 0x1131d0, 0x0 },
+	{ 0x2131d0, 0x0 },
+	{ 0x100d1, 0x0 },
+	{ 0x1100d1, 0x0 },
+	{ 0x2100d1, 0x0 },
+	{ 0x101d1, 0x0 },
+	{ 0x1101d1, 0x0 },
+	{ 0x2101d1, 0x0 },
+	{ 0x110d1, 0x0 },
+	{ 0x1110d1, 0x0 },
+	{ 0x2110d1, 0x0 },
+	{ 0x111d1, 0x0 },
+	{ 0x1111d1, 0x0 },
+	{ 0x2111d1, 0x0 },
+	{ 0x120d1, 0x0 },
+	{ 0x1120d1, 0x0 },
+	{ 0x2120d1, 0x0 },
+	{ 0x121d1, 0x0 },
+	{ 0x1121d1, 0x0 },
+	{ 0x2121d1, 0x0 },
+	{ 0x130d1, 0x0 },
+	{ 0x1130d1, 0x0 },
+	{ 0x2130d1, 0x0 },
+	{ 0x131d1, 0x0 },
+	{ 0x1131d1, 0x0 },
+	{ 0x2131d1, 0x0 },
+	{ 0x10068, 0x0 },
+	{ 0x10168, 0x0 },
+	{ 0x10268, 0x0 },
+	{ 0x10368, 0x0 },
+	{ 0x10468, 0x0 },
+	{ 0x10568, 0x0 },
+	{ 0x10668, 0x0 },
+	{ 0x10768, 0x0 },
+	{ 0x10868, 0x0 },
+	{ 0x11068, 0x0 },
+	{ 0x11168, 0x0 },
+	{ 0x11268, 0x0 },
+	{ 0x11368, 0x0 },
+	{ 0x11468, 0x0 },
+	{ 0x11568, 0x0 },
+	{ 0x11668, 0x0 },
+	{ 0x11768, 0x0 },
+	{ 0x11868, 0x0 },
+	{ 0x12068, 0x0 },
+	{ 0x12168, 0x0 },
+	{ 0x12268, 0x0 },
+	{ 0x12368, 0x0 },
+	{ 0x12468, 0x0 },
+	{ 0x12568, 0x0 },
+	{ 0x12668, 0x0 },
+	{ 0x12768, 0x0 },
+	{ 0x12868, 0x0 },
+	{ 0x13068, 0x0 },
+	{ 0x13168, 0x0 },
+	{ 0x13268, 0x0 },
+	{ 0x13368, 0x0 },
+	{ 0x13468, 0x0 },
+	{ 0x13568, 0x0 },
+	{ 0x13668, 0x0 },
+	{ 0x13768, 0x0 },
+	{ 0x13868, 0x0 },
+	{ 0x10069, 0x0 },
+	{ 0x10169, 0x0 },
+	{ 0x10269, 0x0 },
+	{ 0x10369, 0x0 },
+	{ 0x10469, 0x0 },
+	{ 0x10569, 0x0 },
+	{ 0x10669, 0x0 },
+	{ 0x10769, 0x0 },
+	{ 0x10869, 0x0 },
+	{ 0x11069, 0x0 },
+	{ 0x11169, 0x0 },
+	{ 0x11269, 0x0 },
+	{ 0x11369, 0x0 },
+	{ 0x11469, 0x0 },
+	{ 0x11569, 0x0 },
+	{ 0x11669, 0x0 },
+	{ 0x11769, 0x0 },
+	{ 0x11869, 0x0 },
+	{ 0x12069, 0x0 },
+	{ 0x12169, 0x0 },
+	{ 0x12269, 0x0 },
+	{ 0x12369, 0x0 },
+	{ 0x12469, 0x0 },
+	{ 0x12569, 0x0 },
+	{ 0x12669, 0x0 },
+	{ 0x12769, 0x0 },
+	{ 0x12869, 0x0 },
+	{ 0x13069, 0x0 },
+	{ 0x13169, 0x0 },
+	{ 0x13269, 0x0 },
+	{ 0x13369, 0x0 },
+	{ 0x13469, 0x0 },
+	{ 0x13569, 0x0 },
+	{ 0x13669, 0x0 },
+	{ 0x13769, 0x0 },
+	{ 0x13869, 0x0 },
+	{ 0x1008c, 0x0 },
+	{ 0x11008c, 0x0 },
+	{ 0x21008c, 0x0 },
+	{ 0x1018c, 0x0 },
+	{ 0x11018c, 0x0 },
+	{ 0x21018c, 0x0 },
+	{ 0x1108c, 0x0 },
+	{ 0x11108c, 0x0 },
+	{ 0x21108c, 0x0 },
+	{ 0x1118c, 0x0 },
+	{ 0x11118c, 0x0 },
+	{ 0x21118c, 0x0 },
+	{ 0x1208c, 0x0 },
+	{ 0x11208c, 0x0 },
+	{ 0x21208c, 0x0 },
+	{ 0x1218c, 0x0 },
+	{ 0x11218c, 0x0 },
+	{ 0x21218c, 0x0 },
+	{ 0x1308c, 0x0 },
+	{ 0x11308c, 0x0 },
+	{ 0x21308c, 0x0 },
+	{ 0x1318c, 0x0 },
+	{ 0x11318c, 0x0 },
+	{ 0x21318c, 0x0 },
+	{ 0x1008d, 0x0 },
+	{ 0x11008d, 0x0 },
+	{ 0x21008d, 0x0 },
+	{ 0x1018d, 0x0 },
+	{ 0x11018d, 0x0 },
+	{ 0x21018d, 0x0 },
+	{ 0x1108d, 0x0 },
+	{ 0x11108d, 0x0 },
+	{ 0x21108d, 0x0 },
+	{ 0x1118d, 0x0 },
+	{ 0x11118d, 0x0 },
+	{ 0x21118d, 0x0 },
+	{ 0x1208d, 0x0 },
+	{ 0x11208d, 0x0 },
+	{ 0x21208d, 0x0 },
+	{ 0x1218d, 0x0 },
+	{ 0x11218d, 0x0 },
+	{ 0x21218d, 0x0 },
+	{ 0x1308d, 0x0 },
+	{ 0x11308d, 0x0 },
+	{ 0x21308d, 0x0 },
+	{ 0x1318d, 0x0 },
+	{ 0x11318d, 0x0 },
+	{ 0x21318d, 0x0 },
+	{ 0x100c0, 0x0 },
+	{ 0x1100c0, 0x0 },
+	{ 0x2100c0, 0x0 },
+	{ 0x101c0, 0x0 },
+	{ 0x1101c0, 0x0 },
+	{ 0x2101c0, 0x0 },
+	{ 0x102c0, 0x0 },
+	{ 0x1102c0, 0x0 },
+	{ 0x2102c0, 0x0 },
+	{ 0x103c0, 0x0 },
+	{ 0x1103c0, 0x0 },
+	{ 0x2103c0, 0x0 },
+	{ 0x104c0, 0x0 },
+	{ 0x1104c0, 0x0 },
+	{ 0x2104c0, 0x0 },
+	{ 0x105c0, 0x0 },
+	{ 0x1105c0, 0x0 },
+	{ 0x2105c0, 0x0 },
+	{ 0x106c0, 0x0 },
+	{ 0x1106c0, 0x0 },
+	{ 0x2106c0, 0x0 },
+	{ 0x107c0, 0x0 },
+	{ 0x1107c0, 0x0 },
+	{ 0x2107c0, 0x0 },
+	{ 0x108c0, 0x0 },
+	{ 0x1108c0, 0x0 },
+	{ 0x2108c0, 0x0 },
+	{ 0x110c0, 0x0 },
+	{ 0x1110c0, 0x0 },
+	{ 0x2110c0, 0x0 },
+	{ 0x111c0, 0x0 },
+	{ 0x1111c0, 0x0 },
+	{ 0x2111c0, 0x0 },
+	{ 0x112c0, 0x0 },
+	{ 0x1112c0, 0x0 },
+	{ 0x2112c0, 0x0 },
+	{ 0x113c0, 0x0 },
+	{ 0x1113c0, 0x0 },
+	{ 0x2113c0, 0x0 },
+	{ 0x114c0, 0x0 },
+	{ 0x1114c0, 0x0 },
+	{ 0x2114c0, 0x0 },
+	{ 0x115c0, 0x0 },
+	{ 0x1115c0, 0x0 },
+	{ 0x2115c0, 0x0 },
+	{ 0x116c0, 0x0 },
+	{ 0x1116c0, 0x0 },
+	{ 0x2116c0, 0x0 },
+	{ 0x117c0, 0x0 },
+	{ 0x1117c0, 0x0 },
+	{ 0x2117c0, 0x0 },
+	{ 0x118c0, 0x0 },
+	{ 0x1118c0, 0x0 },
+	{ 0x2118c0, 0x0 },
+	{ 0x120c0, 0x0 },
+	{ 0x1120c0, 0x0 },
+	{ 0x2120c0, 0x0 },
+	{ 0x121c0, 0x0 },
+	{ 0x1121c0, 0x0 },
+	{ 0x2121c0, 0x0 },
+	{ 0x122c0, 0x0 },
+	{ 0x1122c0, 0x0 },
+	{ 0x2122c0, 0x0 },
+	{ 0x123c0, 0x0 },
+	{ 0x1123c0, 0x0 },
+	{ 0x2123c0, 0x0 },
+	{ 0x124c0, 0x0 },
+	{ 0x1124c0, 0x0 },
+	{ 0x2124c0, 0x0 },
+	{ 0x125c0, 0x0 },
+	{ 0x1125c0, 0x0 },
+	{ 0x2125c0, 0x0 },
+	{ 0x126c0, 0x0 },
+	{ 0x1126c0, 0x0 },
+	{ 0x2126c0, 0x0 },
+	{ 0x127c0, 0x0 },
+	{ 0x1127c0, 0x0 },
+	{ 0x2127c0, 0x0 },
+	{ 0x128c0, 0x0 },
+	{ 0x1128c0, 0x0 },
+	{ 0x2128c0, 0x0 },
+	{ 0x130c0, 0x0 },
+	{ 0x1130c0, 0x0 },
+	{ 0x2130c0, 0x0 },
+	{ 0x131c0, 0x0 },
+	{ 0x1131c0, 0x0 },
+	{ 0x2131c0, 0x0 },
+	{ 0x132c0, 0x0 },
+	{ 0x1132c0, 0x0 },
+	{ 0x2132c0, 0x0 },
+	{ 0x133c0, 0x0 },
+	{ 0x1133c0, 0x0 },
+	{ 0x2133c0, 0x0 },
+	{ 0x134c0, 0x0 },
+	{ 0x1134c0, 0x0 },
+	{ 0x2134c0, 0x0 },
+	{ 0x135c0, 0x0 },
+	{ 0x1135c0, 0x0 },
+	{ 0x2135c0, 0x0 },
+	{ 0x136c0, 0x0 },
+	{ 0x1136c0, 0x0 },
+	{ 0x2136c0, 0x0 },
+	{ 0x137c0, 0x0 },
+	{ 0x1137c0, 0x0 },
+	{ 0x2137c0, 0x0 },
+	{ 0x138c0, 0x0 },
+	{ 0x1138c0, 0x0 },
+	{ 0x2138c0, 0x0 },
+	{ 0x100c1, 0x0 },
+	{ 0x1100c1, 0x0 },
+	{ 0x2100c1, 0x0 },
+	{ 0x101c1, 0x0 },
+	{ 0x1101c1, 0x0 },
+	{ 0x2101c1, 0x0 },
+	{ 0x102c1, 0x0 },
+	{ 0x1102c1, 0x0 },
+	{ 0x2102c1, 0x0 },
+	{ 0x103c1, 0x0 },
+	{ 0x1103c1, 0x0 },
+	{ 0x2103c1, 0x0 },
+	{ 0x104c1, 0x0 },
+	{ 0x1104c1, 0x0 },
+	{ 0x2104c1, 0x0 },
+	{ 0x105c1, 0x0 },
+	{ 0x1105c1, 0x0 },
+	{ 0x2105c1, 0x0 },
+	{ 0x106c1, 0x0 },
+	{ 0x1106c1, 0x0 },
+	{ 0x2106c1, 0x0 },
+	{ 0x107c1, 0x0 },
+	{ 0x1107c1, 0x0 },
+	{ 0x2107c1, 0x0 },
+	{ 0x108c1, 0x0 },
+	{ 0x1108c1, 0x0 },
+	{ 0x2108c1, 0x0 },
+	{ 0x110c1, 0x0 },
+	{ 0x1110c1, 0x0 },
+	{ 0x2110c1, 0x0 },
+	{ 0x111c1, 0x0 },
+	{ 0x1111c1, 0x0 },
+	{ 0x2111c1, 0x0 },
+	{ 0x112c1, 0x0 },
+	{ 0x1112c1, 0x0 },
+	{ 0x2112c1, 0x0 },
+	{ 0x113c1, 0x0 },
+	{ 0x1113c1, 0x0 },
+	{ 0x2113c1, 0x0 },
+	{ 0x114c1, 0x0 },
+	{ 0x1114c1, 0x0 },
+	{ 0x2114c1, 0x0 },
+	{ 0x115c1, 0x0 },
+	{ 0x1115c1, 0x0 },
+	{ 0x2115c1, 0x0 },
+	{ 0x116c1, 0x0 },
+	{ 0x1116c1, 0x0 },
+	{ 0x2116c1, 0x0 },
+	{ 0x117c1, 0x0 },
+	{ 0x1117c1, 0x0 },
+	{ 0x2117c1, 0x0 },
+	{ 0x118c1, 0x0 },
+	{ 0x1118c1, 0x0 },
+	{ 0x2118c1, 0x0 },
+	{ 0x120c1, 0x0 },
+	{ 0x1120c1, 0x0 },
+	{ 0x2120c1, 0x0 },
+	{ 0x121c1, 0x0 },
+	{ 0x1121c1, 0x0 },
+	{ 0x2121c1, 0x0 },
+	{ 0x122c1, 0x0 },
+	{ 0x1122c1, 0x0 },
+	{ 0x2122c1, 0x0 },
+	{ 0x123c1, 0x0 },
+	{ 0x1123c1, 0x0 },
+	{ 0x2123c1, 0x0 },
+	{ 0x124c1, 0x0 },
+	{ 0x1124c1, 0x0 },
+	{ 0x2124c1, 0x0 },
+	{ 0x125c1, 0x0 },
+	{ 0x1125c1, 0x0 },
+	{ 0x2125c1, 0x0 },
+	{ 0x126c1, 0x0 },
+	{ 0x1126c1, 0x0 },
+	{ 0x2126c1, 0x0 },
+	{ 0x127c1, 0x0 },
+	{ 0x1127c1, 0x0 },
+	{ 0x2127c1, 0x0 },
+	{ 0x128c1, 0x0 },
+	{ 0x1128c1, 0x0 },
+	{ 0x2128c1, 0x0 },
+	{ 0x130c1, 0x0 },
+	{ 0x1130c1, 0x0 },
+	{ 0x2130c1, 0x0 },
+	{ 0x131c1, 0x0 },
+	{ 0x1131c1, 0x0 },
+	{ 0x2131c1, 0x0 },
+	{ 0x132c1, 0x0 },
+	{ 0x1132c1, 0x0 },
+	{ 0x2132c1, 0x0 },
+	{ 0x133c1, 0x0 },
+	{ 0x1133c1, 0x0 },
+	{ 0x2133c1, 0x0 },
+	{ 0x134c1, 0x0 },
+	{ 0x1134c1, 0x0 },
+	{ 0x2134c1, 0x0 },
+	{ 0x135c1, 0x0 },
+	{ 0x1135c1, 0x0 },
+	{ 0x2135c1, 0x0 },
+	{ 0x136c1, 0x0 },
+	{ 0x1136c1, 0x0 },
+	{ 0x2136c1, 0x0 },
+	{ 0x137c1, 0x0 },
+	{ 0x1137c1, 0x0 },
+	{ 0x2137c1, 0x0 },
+	{ 0x138c1, 0x0 },
+	{ 0x1138c1, 0x0 },
+	{ 0x2138c1, 0x0 },
+	{ 0x10020, 0x0 },
+	{ 0x110020, 0x0 },
+	{ 0x210020, 0x0 },
+	{ 0x11020, 0x0 },
+	{ 0x111020, 0x0 },
+	{ 0x211020, 0x0 },
+	{ 0x12020, 0x0 },
+	{ 0x112020, 0x0 },
+	{ 0x212020, 0x0 },
+	{ 0x13020, 0x0 },
+	{ 0x113020, 0x0 },
+	{ 0x213020, 0x0 },
+	{ 0x20072, 0x0 },
+	{ 0x20073, 0x0 },
+	{ 0x20074, 0x0 },
+	{ 0x100aa, 0x0 },
+	{ 0x110aa, 0x0 },
+	{ 0x120aa, 0x0 },
+	{ 0x130aa, 0x0 },
+	{ 0x20010, 0x0 },
+	{ 0x120010, 0x0 },
+	{ 0x220010, 0x0 },
+	{ 0x20011, 0x0 },
+	{ 0x120011, 0x0 },
+	{ 0x220011, 0x0 },
+	{ 0x100ae, 0x0 },
+	{ 0x1100ae, 0x0 },
+	{ 0x2100ae, 0x0 },
+	{ 0x100af, 0x0 },
+	{ 0x1100af, 0x0 },
+	{ 0x2100af, 0x0 },
+	{ 0x110ae, 0x0 },
+	{ 0x1110ae, 0x0 },
+	{ 0x2110ae, 0x0 },
+	{ 0x110af, 0x0 },
+	{ 0x1110af, 0x0 },
+	{ 0x2110af, 0x0 },
+	{ 0x120ae, 0x0 },
+	{ 0x1120ae, 0x0 },
+	{ 0x2120ae, 0x0 },
+	{ 0x120af, 0x0 },
+	{ 0x1120af, 0x0 },
+	{ 0x2120af, 0x0 },
+	{ 0x130ae, 0x0 },
+	{ 0x1130ae, 0x0 },
+	{ 0x2130ae, 0x0 },
+	{ 0x130af, 0x0 },
+	{ 0x1130af, 0x0 },
+	{ 0x2130af, 0x0 },
+	{ 0x20020, 0x0 },
+	{ 0x120020, 0x0 },
+	{ 0x220020, 0x0 },
+	{ 0x100a0, 0x0 },
+	{ 0x100a1, 0x0 },
+	{ 0x100a2, 0x0 },
+	{ 0x100a3, 0x0 },
+	{ 0x100a4, 0x0 },
+	{ 0x100a5, 0x0 },
+	{ 0x100a6, 0x0 },
+	{ 0x100a7, 0x0 },
+	{ 0x110a0, 0x0 },
+	{ 0x110a1, 0x0 },
+	{ 0x110a2, 0x0 },
+	{ 0x110a3, 0x0 },
+	{ 0x110a4, 0x0 },
+	{ 0x110a5, 0x0 },
+	{ 0x110a6, 0x0 },
+	{ 0x110a7, 0x0 },
+	{ 0x120a0, 0x0 },
+	{ 0x120a1, 0x0 },
+	{ 0x120a2, 0x0 },
+	{ 0x120a3, 0x0 },
+	{ 0x120a4, 0x0 },
+	{ 0x120a5, 0x0 },
+	{ 0x120a6, 0x0 },
+	{ 0x120a7, 0x0 },
+	{ 0x130a0, 0x0 },
+	{ 0x130a1, 0x0 },
+	{ 0x130a2, 0x0 },
+	{ 0x130a3, 0x0 },
+	{ 0x130a4, 0x0 },
+	{ 0x130a5, 0x0 },
+	{ 0x130a6, 0x0 },
+	{ 0x130a7, 0x0 },
+	{ 0x2007c, 0x0 },
+	{ 0x12007c, 0x0 },
+	{ 0x22007c, 0x0 },
+	{ 0x2007d, 0x0 },
+	{ 0x12007d, 0x0 },
+	{ 0x22007d, 0x0 },
+	{ 0x400fd, 0x0 },
+	{ 0x400c0, 0x0 },
+	{ 0x90201, 0x0 },
+	{ 0x190201, 0x0 },
+	{ 0x290201, 0x0 },
+	{ 0x90202, 0x0 },
+	{ 0x190202, 0x0 },
+	{ 0x290202, 0x0 },
+	{ 0x90203, 0x0 },
+	{ 0x190203, 0x0 },
+	{ 0x290203, 0x0 },
+	{ 0x90204, 0x0 },
+	{ 0x190204, 0x0 },
+	{ 0x290204, 0x0 },
+	{ 0x90205, 0x0 },
+	{ 0x190205, 0x0 },
+	{ 0x290205, 0x0 },
+	{ 0x90206, 0x0 },
+	{ 0x190206, 0x0 },
+	{ 0x290206, 0x0 },
+	{ 0x90207, 0x0 },
+	{ 0x190207, 0x0 },
+	{ 0x290207, 0x0 },
+	{ 0x90208, 0x0 },
+	{ 0x190208, 0x0 },
+	{ 0x290208, 0x0 },
+	{ 0x10062, 0x0 },
+	{ 0x10162, 0x0 },
+	{ 0x10262, 0x0 },
+	{ 0x10362, 0x0 },
+	{ 0x10462, 0x0 },
+	{ 0x10562, 0x0 },
+	{ 0x10662, 0x0 },
+	{ 0x10762, 0x0 },
+	{ 0x10862, 0x0 },
+	{ 0x11062, 0x0 },
+	{ 0x11162, 0x0 },
+	{ 0x11262, 0x0 },
+	{ 0x11362, 0x0 },
+	{ 0x11462, 0x0 },
+	{ 0x11562, 0x0 },
+	{ 0x11662, 0x0 },
+	{ 0x11762, 0x0 },
+	{ 0x11862, 0x0 },
+	{ 0x12062, 0x0 },
+	{ 0x12162, 0x0 },
+	{ 0x12262, 0x0 },
+	{ 0x12362, 0x0 },
+	{ 0x12462, 0x0 },
+	{ 0x12562, 0x0 },
+	{ 0x12662, 0x0 },
+	{ 0x12762, 0x0 },
+	{ 0x12862, 0x0 },
+	{ 0x13062, 0x0 },
+	{ 0x13162, 0x0 },
+	{ 0x13262, 0x0 },
+	{ 0x13362, 0x0 },
+	{ 0x13462, 0x0 },
+	{ 0x13562, 0x0 },
+	{ 0x13662, 0x0 },
+	{ 0x13762, 0x0 },
+	{ 0x13862, 0x0 },
+	{ 0x20077, 0x0 },
+	{ 0x10001, 0x0 },
+	{ 0x11001, 0x0 },
+	{ 0x12001, 0x0 },
+	{ 0x13001, 0x0 },
+	{ 0x10040, 0x0 },
+	{ 0x10140, 0x0 },
+	{ 0x10240, 0x0 },
+	{ 0x10340, 0x0 },
+	{ 0x10440, 0x0 },
+	{ 0x10540, 0x0 },
+	{ 0x10640, 0x0 },
+	{ 0x10740, 0x0 },
+	{ 0x10840, 0x0 },
+	{ 0x10030, 0x0 },
+	{ 0x10130, 0x0 },
+	{ 0x10230, 0x0 },
+	{ 0x10330, 0x0 },
+	{ 0x10430, 0x0 },
+	{ 0x10530, 0x0 },
+	{ 0x10630, 0x0 },
+	{ 0x10730, 0x0 },
+	{ 0x10830, 0x0 },
+	{ 0x11040, 0x0 },
+	{ 0x11140, 0x0 },
+	{ 0x11240, 0x0 },
+	{ 0x11340, 0x0 },
+	{ 0x11440, 0x0 },
+	{ 0x11540, 0x0 },
+	{ 0x11640, 0x0 },
+	{ 0x11740, 0x0 },
+	{ 0x11840, 0x0 },
+	{ 0x11030, 0x0 },
+	{ 0x11130, 0x0 },
+	{ 0x11230, 0x0 },
+	{ 0x11330, 0x0 },
+	{ 0x11430, 0x0 },
+	{ 0x11530, 0x0 },
+	{ 0x11630, 0x0 },
+	{ 0x11730, 0x0 },
+	{ 0x11830, 0x0 },
+	{ 0x12040, 0x0 },
+	{ 0x12140, 0x0 },
+	{ 0x12240, 0x0 },
+	{ 0x12340, 0x0 },
+	{ 0x12440, 0x0 },
+	{ 0x12540, 0x0 },
+	{ 0x12640, 0x0 },
+	{ 0x12740, 0x0 },
+	{ 0x12840, 0x0 },
+	{ 0x12030, 0x0 },
+	{ 0x12130, 0x0 },
+	{ 0x12230, 0x0 },
+	{ 0x12330, 0x0 },
+	{ 0x12430, 0x0 },
+	{ 0x12530, 0x0 },
+	{ 0x12630, 0x0 },
+	{ 0x12730, 0x0 },
+	{ 0x12830, 0x0 },
+	{ 0x13040, 0x0 },
+	{ 0x13140, 0x0 },
+	{ 0x13240, 0x0 },
+	{ 0x13340, 0x0 },
+	{ 0x13440, 0x0 },
+	{ 0x13540, 0x0 },
+	{ 0x13640, 0x0 },
+	{ 0x13740, 0x0 },
+	{ 0x13840, 0x0 },
+	{ 0x13030, 0x0 },
+	{ 0x13130, 0x0 },
+	{ 0x13230, 0x0 },
+	{ 0x13330, 0x0 },
+	{ 0x13430, 0x0 },
+	{ 0x13530, 0x0 },
+	{ 0x13630, 0x0 },
+	{ 0x13730, 0x0 },
+	{ 0x13830, 0x0 },
+};
+/* P0 message block paremeter for training firmware */
+struct dram_cfg_param ddr_fsp0_cfg[] = {
+	{ 0xd0000, 0x0 },
+	{ 0x54003, 0xbb8 },
+	{ 0x54004, 0x2 },
+	{ 0x54005, 0x2228 },
+	{ 0x54006, 0x14 },
+	{ 0x54008, 0x131f },
+	{ 0x54009, 0xc8 },
+	{ 0x5400b, 0x2 },
+	{ 0x5400f, 0x100 },
+	{ 0x54012, 0x110 },
+	{ 0x54019, 0x2dd4 },
+	{ 0x5401a, 0x33 },
+	{ 0x5401b, 0x4866 },
+	{ 0x5401c, 0x4800 },
+	{ 0x5401e, 0x16 },
+	{ 0x5401f, 0x2dd4 },
+	{ 0x54020, 0x33 },
+	{ 0x54021, 0x4866 },
+	{ 0x54022, 0x4800 },
+	{ 0x54024, 0x16 },
+	{ 0x5402b, 0x1000 },
+	{ 0x5402c, 0x1 },
+	{ 0x54032, 0xd400 },
+	{ 0x54033, 0x332d },
+	{ 0x54034, 0x6600 },
+	{ 0x54035, 0x48 },
+	{ 0x54036, 0x48 },
+	{ 0x54037, 0x1600 },
+	{ 0x54038, 0xd400 },
+	{ 0x54039, 0x332d },
+	{ 0x5403a, 0x6600 },
+	{ 0x5403b, 0x48 },
+	{ 0x5403c, 0x48 },
+	{ 0x5403d, 0x1600 },
+	{ 0xd0000, 0x1 },
+};
+
+
+/* P1 message block paremeter for training firmware */
+struct dram_cfg_param ddr_fsp1_cfg[] = {
+	{ 0xd0000, 0x0 },
+	{ 0x54002, 0x101 },
+	{ 0x54003, 0x190 },
+	{ 0x54004, 0x2 },
+	{ 0x54005, 0x2228 },
+	{ 0x54006, 0x14 },
+	{ 0x54008, 0x121f },
+	{ 0x54009, 0xc8 },
+	{ 0x5400b, 0x2 },
+	{ 0x5400f, 0x100 },
+	{ 0x54012, 0x110 },
+	{ 0x54019, 0x84 },
+	{ 0x5401a, 0x33 },
+	{ 0x5401b, 0x4866 },
+	{ 0x5401c, 0x4800 },
+	{ 0x5401e, 0x16 },
+	{ 0x5401f, 0x84 },
+	{ 0x54020, 0x33 },
+	{ 0x54021, 0x4866 },
+	{ 0x54022, 0x4800 },
+	{ 0x54024, 0x16 },
+	{ 0x5402b, 0x1000 },
+	{ 0x5402c, 0x1 },
+	{ 0x54032, 0x8400 },
+	{ 0x54033, 0x3300 },
+	{ 0x54034, 0x6600 },
+	{ 0x54035, 0x48 },
+	{ 0x54036, 0x48 },
+	{ 0x54037, 0x1600 },
+	{ 0x54038, 0x8400 },
+	{ 0x54039, 0x3300 },
+	{ 0x5403a, 0x6600 },
+	{ 0x5403b, 0x48 },
+	{ 0x5403c, 0x48 },
+	{ 0x5403d, 0x1600 },
+	{ 0xd0000, 0x1 },
+};
+
+
+/* P2 message block paremeter for training firmware */
+struct dram_cfg_param ddr_fsp2_cfg[] = {
+	{ 0xd0000, 0x0 },
+	{ 0x54002, 0x102 },
+	{ 0x54003, 0x64 },
+	{ 0x54004, 0x2 },
+	{ 0x54005, 0x2228 },
+	{ 0x54006, 0x14 },
+	{ 0x54008, 0x121f },
+	{ 0x54009, 0xc8 },
+	{ 0x5400b, 0x2 },
+	{ 0x5400f, 0x100 },
+	{ 0x54012, 0x110 },
+	{ 0x54019, 0x84 },
+	{ 0x5401a, 0x33 },
+	{ 0x5401b, 0x4866 },
+	{ 0x5401c, 0x4800 },
+	{ 0x5401e, 0x16 },
+	{ 0x5401f, 0x84 },
+	{ 0x54020, 0x33 },
+	{ 0x54021, 0x4866 },
+	{ 0x54022, 0x4800 },
+	{ 0x54024, 0x16 },
+	{ 0x5402b, 0x1000 },
+	{ 0x5402c, 0x1 },
+	{ 0x54032, 0x8400 },
+	{ 0x54033, 0x3300 },
+	{ 0x54034, 0x6600 },
+	{ 0x54035, 0x48 },
+	{ 0x54036, 0x48 },
+	{ 0x54037, 0x1600 },
+	{ 0x54038, 0x8400 },
+	{ 0x54039, 0x3300 },
+	{ 0x5403a, 0x6600 },
+	{ 0x5403b, 0x48 },
+	{ 0x5403c, 0x48 },
+	{ 0x5403d, 0x1600 },
+	{ 0xd0000, 0x1 },
+};
+
+
+/* P0 2D message block paremeter for training firmware */
+struct dram_cfg_param ddr_fsp0_2d_cfg[] = {
+	{ 0xd0000, 0x0 },
+	{ 0x54003, 0xbb8 },
+	{ 0x54004, 0x2 },
+	{ 0x54005, 0x2228 },
+	{ 0x54006, 0x14 },
+	{ 0x54008, 0x61 },
+	{ 0x54009, 0xc8 },
+	{ 0x5400b, 0x2 },
+	{ 0x5400f, 0x100 },
+	{ 0x54010, 0x1f7f },
+	{ 0x54012, 0x110 },
+	{ 0x54019, 0x2dd4 },
+	{ 0x5401a, 0x33 },
+	{ 0x5401b, 0x4866 },
+	{ 0x5401c, 0x4800 },
+	{ 0x5401e, 0x16 },
+	{ 0x5401f, 0x2dd4 },
+	{ 0x54020, 0x33 },
+	{ 0x54021, 0x4866 },
+	{ 0x54022, 0x4800 },
+	{ 0x54024, 0x16 },
+	{ 0x5402b, 0x1000 },
+	{ 0x5402c, 0x1 },
+	{ 0x54032, 0xd400 },
+	{ 0x54033, 0x332d },
+	{ 0x54034, 0x6600 },
+	{ 0x54035, 0x48 },
+	{ 0x54036, 0x48 },
+	{ 0x54037, 0x1600 },
+	{ 0x54038, 0xd400 },
+	{ 0x54039, 0x332d },
+	{ 0x5403a, 0x6600 },
+	{ 0x5403b, 0x48 },
+	{ 0x5403c, 0x48 },
+	{ 0x5403d, 0x1600 },
+	{ 0xd0000, 0x1 },
+};
+
+/* DRAM PHY init engine image */
+struct dram_cfg_param ddr_phy_pie[] = {
+	{ 0xd0000, 0x0 },
+	{ 0x90000, 0x10 },
+	{ 0x90001, 0x400 },
+	{ 0x90002, 0x10e },
+	{ 0x90003, 0x0 },
+	{ 0x90004, 0x0 },
+	{ 0x90005, 0x8 },
+	{ 0x90029, 0xb },
+	{ 0x9002a, 0x480 },
+	{ 0x9002b, 0x109 },
+	{ 0x9002c, 0x8 },
+	{ 0x9002d, 0x448 },
+	{ 0x9002e, 0x139 },
+	{ 0x9002f, 0x8 },
+	{ 0x90030, 0x478 },
+	{ 0x90031, 0x109 },
+	{ 0x90032, 0x0 },
+	{ 0x90033, 0xe8 },
+	{ 0x90034, 0x109 },
+	{ 0x90035, 0x2 },
+	{ 0x90036, 0x10 },
+	{ 0x90037, 0x139 },
+	{ 0x90038, 0xb },
+	{ 0x90039, 0x7c0 },
+	{ 0x9003a, 0x139 },
+	{ 0x9003b, 0x44 },
+	{ 0x9003c, 0x633 },
+	{ 0x9003d, 0x159 },
+	{ 0x9003e, 0x14f },
+	{ 0x9003f, 0x630 },
+	{ 0x90040, 0x159 },
+	{ 0x90041, 0x47 },
+	{ 0x90042, 0x633 },
+	{ 0x90043, 0x149 },
+	{ 0x90044, 0x4f },
+	{ 0x90045, 0x633 },
+	{ 0x90046, 0x179 },
+	{ 0x90047, 0x8 },
+	{ 0x90048, 0xe0 },
+	{ 0x90049, 0x109 },
+	{ 0x9004a, 0x0 },
+	{ 0x9004b, 0x7c8 },
+	{ 0x9004c, 0x109 },
+	{ 0x9004d, 0x0 },
+	{ 0x9004e, 0x1 },
+	{ 0x9004f, 0x8 },
+	{ 0x90050, 0x0 },
+	{ 0x90051, 0x45a },
+	{ 0x90052, 0x9 },
+	{ 0x90053, 0x0 },
+	{ 0x90054, 0x448 },
+	{ 0x90055, 0x109 },
+	{ 0x90056, 0x40 },
+	{ 0x90057, 0x633 },
+	{ 0x90058, 0x179 },
+	{ 0x90059, 0x1 },
+	{ 0x9005a, 0x618 },
+	{ 0x9005b, 0x109 },
+	{ 0x9005c, 0x40c0 },
+	{ 0x9005d, 0x633 },
+	{ 0x9005e, 0x149 },
+	{ 0x9005f, 0x8 },
+	{ 0x90060, 0x4 },
+	{ 0x90061, 0x48 },
+	{ 0x90062, 0x4040 },
+	{ 0x90063, 0x633 },
+	{ 0x90064, 0x149 },
+	{ 0x90065, 0x0 },
+	{ 0x90066, 0x4 },
+	{ 0x90067, 0x48 },
+	{ 0x90068, 0x40 },
+	{ 0x90069, 0x633 },
+	{ 0x9006a, 0x149 },
+	{ 0x9006b, 0x10 },
+	{ 0x9006c, 0x4 },
+	{ 0x9006d, 0x18 },
+	{ 0x9006e, 0x0 },
+	{ 0x9006f, 0x4 },
+	{ 0x90070, 0x78 },
+	{ 0x90071, 0x549 },
+	{ 0x90072, 0x633 },
+	{ 0x90073, 0x159 },
+	{ 0x90074, 0xd49 },
+	{ 0x90075, 0x633 },
+	{ 0x90076, 0x159 },
+	{ 0x90077, 0x94a },
+	{ 0x90078, 0x633 },
+	{ 0x90079, 0x159 },
+	{ 0x9007a, 0x441 },
+	{ 0x9007b, 0x633 },
+	{ 0x9007c, 0x149 },
+	{ 0x9007d, 0x42 },
+	{ 0x9007e, 0x633 },
+	{ 0x9007f, 0x149 },
+	{ 0x90080, 0x1 },
+	{ 0x90081, 0x633 },
+	{ 0x90082, 0x149 },
+	{ 0x90083, 0x0 },
+	{ 0x90084, 0xe0 },
+	{ 0x90085, 0x109 },
+	{ 0x90086, 0xa },
+	{ 0x90087, 0x10 },
+	{ 0x90088, 0x109 },
+	{ 0x90089, 0x9 },
+	{ 0x9008a, 0x3c0 },
+	{ 0x9008b, 0x149 },
+	{ 0x9008c, 0x9 },
+	{ 0x9008d, 0x3c0 },
+	{ 0x9008e, 0x159 },
+	{ 0x9008f, 0x18 },
+	{ 0x90090, 0x10 },
+	{ 0x90091, 0x109 },
+	{ 0x90092, 0x0 },
+	{ 0x90093, 0x3c0 },
+	{ 0x90094, 0x109 },
+	{ 0x90095, 0x18 },
+	{ 0x90096, 0x4 },
+	{ 0x90097, 0x48 },
+	{ 0x90098, 0x18 },
+	{ 0x90099, 0x4 },
+	{ 0x9009a, 0x58 },
+	{ 0x9009b, 0xb },
+	{ 0x9009c, 0x10 },
+	{ 0x9009d, 0x109 },
+	{ 0x9009e, 0x1 },
+	{ 0x9009f, 0x10 },
+	{ 0x900a0, 0x109 },
+	{ 0x900a1, 0x5 },
+	{ 0x900a2, 0x7c0 },
+	{ 0x900a3, 0x109 },
+	{ 0x40000, 0x811 },
+	{ 0x40020, 0x880 },
+	{ 0x40040, 0x0 },
+	{ 0x40060, 0x0 },
+	{ 0x40001, 0x4008 },
+	{ 0x40021, 0x83 },
+	{ 0x40041, 0x4f },
+	{ 0x40061, 0x0 },
+	{ 0x40002, 0x4040 },
+	{ 0x40022, 0x83 },
+	{ 0x40042, 0x51 },
+	{ 0x40062, 0x0 },
+	{ 0x40003, 0x811 },
+	{ 0x40023, 0x880 },
+	{ 0x40043, 0x0 },
+	{ 0x40063, 0x0 },
+	{ 0x40004, 0x720 },
+	{ 0x40024, 0xf },
+	{ 0x40044, 0x1740 },
+	{ 0x40064, 0x0 },
+	{ 0x40005, 0x16 },
+	{ 0x40025, 0x83 },
+	{ 0x40045, 0x4b },
+	{ 0x40065, 0x0 },
+	{ 0x40006, 0x716 },
+	{ 0x40026, 0xf },
+	{ 0x40046, 0x2001 },
+	{ 0x40066, 0x0 },
+	{ 0x40007, 0x716 },
+	{ 0x40027, 0xf },
+	{ 0x40047, 0x2800 },
+	{ 0x40067, 0x0 },
+	{ 0x40008, 0x716 },
+	{ 0x40028, 0xf },
+	{ 0x40048, 0xf00 },
+	{ 0x40068, 0x0 },
+	{ 0x40009, 0x720 },
+	{ 0x40029, 0xf },
+	{ 0x40049, 0x1400 },
+	{ 0x40069, 0x0 },
+	{ 0x4000a, 0xe08 },
+	{ 0x4002a, 0xc15 },
+	{ 0x4004a, 0x0 },
+	{ 0x4006a, 0x0 },
+	{ 0x4000b, 0x625 },
+	{ 0x4002b, 0x15 },
+	{ 0x4004b, 0x0 },
+	{ 0x4006b, 0x0 },
+	{ 0x4000c, 0x4028 },
+	{ 0x4002c, 0x80 },
+	{ 0x4004c, 0x0 },
+	{ 0x4006c, 0x0 },
+	{ 0x4000d, 0xe08 },
+	{ 0x4002d, 0xc1a },
+	{ 0x4004d, 0x0 },
+	{ 0x4006d, 0x0 },
+	{ 0x4000e, 0x625 },
+	{ 0x4002e, 0x1a },
+	{ 0x4004e, 0x0 },
+	{ 0x4006e, 0x0 },
+	{ 0x4000f, 0x4040 },
+	{ 0x4002f, 0x80 },
+	{ 0x4004f, 0x0 },
+	{ 0x4006f, 0x0 },
+	{ 0x40010, 0x2604 },
+	{ 0x40030, 0x15 },
+	{ 0x40050, 0x0 },
+	{ 0x40070, 0x0 },
+	{ 0x40011, 0x708 },
+	{ 0x40031, 0x5 },
+	{ 0x40051, 0x0 },
+	{ 0x40071, 0x2002 },
+	{ 0x40012, 0x8 },
+	{ 0x40032, 0x80 },
+	{ 0x40052, 0x0 },
+	{ 0x40072, 0x0 },
+	{ 0x40013, 0x2604 },
+	{ 0x40033, 0x1a },
+	{ 0x40053, 0x0 },
+	{ 0x40073, 0x0 },
+	{ 0x40014, 0x708 },
+	{ 0x40034, 0xa },
+	{ 0x40054, 0x0 },
+	{ 0x40074, 0x2002 },
+	{ 0x40015, 0x4040 },
+	{ 0x40035, 0x80 },
+	{ 0x40055, 0x0 },
+	{ 0x40075, 0x0 },
+	{ 0x40016, 0x60a },
+	{ 0x40036, 0x15 },
+	{ 0x40056, 0x1200 },
+	{ 0x40076, 0x0 },
+	{ 0x40017, 0x61a },
+	{ 0x40037, 0x15 },
+	{ 0x40057, 0x1300 },
+	{ 0x40077, 0x0 },
+	{ 0x40018, 0x60a },
+	{ 0x40038, 0x1a },
+	{ 0x40058, 0x1200 },
+	{ 0x40078, 0x0 },
+	{ 0x40019, 0x642 },
+	{ 0x40039, 0x1a },
+	{ 0x40059, 0x1300 },
+	{ 0x40079, 0x0 },
+	{ 0x4001a, 0x4808 },
+	{ 0x4003a, 0x880 },
+	{ 0x4005a, 0x0 },
+	{ 0x4007a, 0x0 },
+	{ 0x900a4, 0x0 },
+	{ 0x900a5, 0x790 },
+	{ 0x900a6, 0x11a },
+	{ 0x900a7, 0x8 },
+	{ 0x900a8, 0x7aa },
+	{ 0x900a9, 0x2a },
+	{ 0x900aa, 0x10 },
+	{ 0x900ab, 0x7b2 },
+	{ 0x900ac, 0x2a },
+	{ 0x900ad, 0x0 },
+	{ 0x900ae, 0x7c8 },
+	{ 0x900af, 0x109 },
+	{ 0x900b0, 0x10 },
+	{ 0x900b1, 0x10 },
+	{ 0x900b2, 0x109 },
+	{ 0x900b3, 0x10 },
+	{ 0x900b4, 0x2a8 },
+	{ 0x900b5, 0x129 },
+	{ 0x900b6, 0x8 },
+	{ 0x900b7, 0x370 },
+	{ 0x900b8, 0x129 },
+	{ 0x900b9, 0xa },
+	{ 0x900ba, 0x3c8 },
+	{ 0x900bb, 0x1a9 },
+	{ 0x900bc, 0xc },
+	{ 0x900bd, 0x408 },
+	{ 0x900be, 0x199 },
+	{ 0x900bf, 0x14 },
+	{ 0x900c0, 0x790 },
+	{ 0x900c1, 0x11a },
+	{ 0x900c2, 0x8 },
+	{ 0x900c3, 0x4 },
+	{ 0x900c4, 0x18 },
+	{ 0x900c5, 0xe },
+	{ 0x900c6, 0x408 },
+	{ 0x900c7, 0x199 },
+	{ 0x900c8, 0x8 },
+	{ 0x900c9, 0x8568 },
+	{ 0x900ca, 0x108 },
+	{ 0x900cb, 0x18 },
+	{ 0x900cc, 0x790 },
+	{ 0x900cd, 0x16a },
+	{ 0x900ce, 0x8 },
+	{ 0x900cf, 0x1d8 },
+	{ 0x900d0, 0x169 },
+	{ 0x900d1, 0x10 },
+	{ 0x900d2, 0x8558 },
+	{ 0x900d3, 0x168 },
+	{ 0x900d4, 0x70 },
+	{ 0x900d5, 0x788 },
+	{ 0x900d6, 0x16a },
+	{ 0x900d7, 0x1ff8 },
+	{ 0x900d8, 0x85a8 },
+	{ 0x900d9, 0x1e8 },
+	{ 0x900da, 0x50 },
+	{ 0x900db, 0x798 },
+	{ 0x900dc, 0x16a },
+	{ 0x900dd, 0x60 },
+	{ 0x900de, 0x7a0 },
+	{ 0x900df, 0x16a },
+	{ 0x900e0, 0x8 },
+	{ 0x900e1, 0x8310 },
+	{ 0x900e2, 0x168 },
+	{ 0x900e3, 0x8 },
+	{ 0x900e4, 0xa310 },
+	{ 0x900e5, 0x168 },
+	{ 0x900e6, 0xa },
+	{ 0x900e7, 0x408 },
+	{ 0x900e8, 0x169 },
+	{ 0x900e9, 0x6e },
+	{ 0x900ea, 0x0 },
+	{ 0x900eb, 0x68 },
+	{ 0x900ec, 0x0 },
+	{ 0x900ed, 0x408 },
+	{ 0x900ee, 0x169 },
+	{ 0x900ef, 0x0 },
+	{ 0x900f0, 0x8310 },
+	{ 0x900f1, 0x168 },
+	{ 0x900f2, 0x0 },
+	{ 0x900f3, 0xa310 },
+	{ 0x900f4, 0x168 },
+	{ 0x900f5, 0x1ff8 },
+	{ 0x900f6, 0x85a8 },
+	{ 0x900f7, 0x1e8 },
+	{ 0x900f8, 0x68 },
+	{ 0x900f9, 0x798 },
+	{ 0x900fa, 0x16a },
+	{ 0x900fb, 0x78 },
+	{ 0x900fc, 0x7a0 },
+	{ 0x900fd, 0x16a },
+	{ 0x900fe, 0x68 },
+	{ 0x900ff, 0x790 },
+	{ 0x90100, 0x16a },
+	{ 0x90101, 0x8 },
+	{ 0x90102, 0x8b10 },
+	{ 0x90103, 0x168 },
+	{ 0x90104, 0x8 },
+	{ 0x90105, 0xab10 },
+	{ 0x90106, 0x168 },
+	{ 0x90107, 0xa },
+	{ 0x90108, 0x408 },
+	{ 0x90109, 0x169 },
+	{ 0x9010a, 0x58 },
+	{ 0x9010b, 0x0 },
+	{ 0x9010c, 0x68 },
+	{ 0x9010d, 0x0 },
+	{ 0x9010e, 0x408 },
+	{ 0x9010f, 0x169 },
+	{ 0x90110, 0x0 },
+	{ 0x90111, 0x8b10 },
+	{ 0x90112, 0x168 },
+	{ 0x90113, 0x1 },
+	{ 0x90114, 0xab10 },
+	{ 0x90115, 0x168 },
+	{ 0x90116, 0x0 },
+	{ 0x90117, 0x1d8 },
+	{ 0x90118, 0x169 },
+	{ 0x90119, 0x80 },
+	{ 0x9011a, 0x790 },
+	{ 0x9011b, 0x16a },
+	{ 0x9011c, 0x18 },
+	{ 0x9011d, 0x7aa },
+	{ 0x9011e, 0x6a },
+	{ 0x9011f, 0xa },
+	{ 0x90120, 0x0 },
+	{ 0x90121, 0x1e9 },
+	{ 0x90122, 0x8 },
+	{ 0x90123, 0x8080 },
+	{ 0x90124, 0x108 },
+	{ 0x90125, 0xf },
+	{ 0x90126, 0x408 },
+	{ 0x90127, 0x169 },
+	{ 0x90128, 0xc },
+	{ 0x90129, 0x0 },
+	{ 0x9012a, 0x68 },
+	{ 0x9012b, 0x9 },
+	{ 0x9012c, 0x0 },
+	{ 0x9012d, 0x1a9 },
+	{ 0x9012e, 0x0 },
+	{ 0x9012f, 0x408 },
+	{ 0x90130, 0x169 },
+	{ 0x90131, 0x0 },
+	{ 0x90132, 0x8080 },
+	{ 0x90133, 0x108 },
+	{ 0x90134, 0x8 },
+	{ 0x90135, 0x7aa },
+	{ 0x90136, 0x6a },
+	{ 0x90137, 0x0 },
+	{ 0x90138, 0x8568 },
+	{ 0x90139, 0x108 },
+	{ 0x9013a, 0xb7 },
+	{ 0x9013b, 0x790 },
+	{ 0x9013c, 0x16a },
+	{ 0x9013d, 0x1f },
+	{ 0x9013e, 0x0 },
+	{ 0x9013f, 0x68 },
+	{ 0x90140, 0x8 },
+	{ 0x90141, 0x8558 },
+	{ 0x90142, 0x168 },
+	{ 0x90143, 0xf },
+	{ 0x90144, 0x408 },
+	{ 0x90145, 0x169 },
+	{ 0x90146, 0xd },
+	{ 0x90147, 0x0 },
+	{ 0x90148, 0x68 },
+	{ 0x90149, 0x0 },
+	{ 0x9014a, 0x408 },
+	{ 0x9014b, 0x169 },
+	{ 0x9014c, 0x0 },
+	{ 0x9014d, 0x8558 },
+	{ 0x9014e, 0x168 },
+	{ 0x9014f, 0x8 },
+	{ 0x90150, 0x3c8 },
+	{ 0x90151, 0x1a9 },
+	{ 0x90152, 0x3 },
+	{ 0x90153, 0x370 },
+	{ 0x90154, 0x129 },
+	{ 0x90155, 0x20 },
+	{ 0x90156, 0x2aa },
+	{ 0x90157, 0x9 },
+	{ 0x90158, 0x8 },
+	{ 0x90159, 0xe8 },
+	{ 0x9015a, 0x109 },
+	{ 0x9015b, 0x0 },
+	{ 0x9015c, 0x8140 },
+	{ 0x9015d, 0x10c },
+	{ 0x9015e, 0x10 },
+	{ 0x9015f, 0x8138 },
+	{ 0x90160, 0x104 },
+	{ 0x90161, 0x8 },
+	{ 0x90162, 0x448 },
+	{ 0x90163, 0x109 },
+	{ 0x90164, 0xf },
+	{ 0x90165, 0x7c0 },
+	{ 0x90166, 0x109 },
+	{ 0x90167, 0x0 },
+	{ 0x90168, 0xe8 },
+	{ 0x90169, 0x109 },
+	{ 0x9016a, 0x47 },
+	{ 0x9016b, 0x630 },
+	{ 0x9016c, 0x109 },
+	{ 0x9016d, 0x8 },
+	{ 0x9016e, 0x618 },
+	{ 0x9016f, 0x109 },
+	{ 0x90170, 0x8 },
+	{ 0x90171, 0xe0 },
+	{ 0x90172, 0x109 },
+	{ 0x90173, 0x0 },
+	{ 0x90174, 0x7c8 },
+	{ 0x90175, 0x109 },
+	{ 0x90176, 0x8 },
+	{ 0x90177, 0x8140 },
+	{ 0x90178, 0x10c },
+	{ 0x90179, 0x0 },
+	{ 0x9017a, 0x478 },
+	{ 0x9017b, 0x109 },
+	{ 0x9017c, 0x0 },
+	{ 0x9017d, 0x1 },
+	{ 0x9017e, 0x8 },
+	{ 0x9017f, 0x8 },
+	{ 0x90180, 0x4 },
+	{ 0x90181, 0x0 },
+	{ 0x90006, 0x8 },
+	{ 0x90007, 0x7c8 },
+	{ 0x90008, 0x109 },
+	{ 0x90009, 0x0 },
+	{ 0x9000a, 0x400 },
+	{ 0x9000b, 0x106 },
+	{ 0xd00e7, 0x400 },
+	{ 0x90017, 0x0 },
+	{ 0x9001f, 0x29 },
+	{ 0x90026, 0x68 },
+	{ 0x400d0, 0x0 },
+	{ 0x400d1, 0x101 },
+	{ 0x400d2, 0x105 },
+	{ 0x400d3, 0x107 },
+	{ 0x400d4, 0x10f },
+	{ 0x400d5, 0x202 },
+	{ 0x400d6, 0x20a },
+	{ 0x400d7, 0x20b },
+	{ 0x2003a, 0x2 },
+	{ 0x200be, 0x3 },
+	{ 0x2000b, 0x5d },
+	{ 0x2000c, 0xbb },
+	{ 0x2000d, 0x753 },
+	{ 0x2000e, 0x2c },
+	{ 0x12000b, 0xc },
+	{ 0x12000c, 0x19 },
+	{ 0x12000d, 0xfa },
+	{ 0x12000e, 0x10 },
+	{ 0x22000b, 0x3 },
+	{ 0x22000c, 0x6 },
+	{ 0x22000d, 0x3e },
+	{ 0x22000e, 0x10 },
+	{ 0x9000c, 0x0 },
+	{ 0x9000d, 0x173 },
+	{ 0x9000e, 0x60 },
+	{ 0x9000f, 0x6110 },
+	{ 0x90010, 0x2152 },
+	{ 0x90011, 0xdfbd },
+	{ 0x90012, 0x2060 },
+	{ 0x90013, 0x6152 },
+	{ 0x20010, 0x5a },
+	{ 0x20011, 0x3 },
+	{ 0x40080, 0xe0 },
+	{ 0x40081, 0x12 },
+	{ 0x40082, 0xe0 },
+	{ 0x40083, 0x12 },
+	{ 0x40084, 0xe0 },
+	{ 0x40085, 0x12 },
+	{ 0x140080, 0xe0 },
+	{ 0x140081, 0x12 },
+	{ 0x140082, 0xe0 },
+	{ 0x140083, 0x12 },
+	{ 0x140084, 0xe0 },
+	{ 0x140085, 0x12 },
+	{ 0x240080, 0xe0 },
+	{ 0x240081, 0x12 },
+	{ 0x240082, 0xe0 },
+	{ 0x240083, 0x12 },
+	{ 0x240084, 0xe0 },
+	{ 0x240085, 0x12 },
+	{ 0x400fd, 0xf },
+	{ 0x10011, 0x1 },
+	{ 0x10012, 0x1 },
+	{ 0x10013, 0x180 },
+	{ 0x10018, 0x1 },
+	{ 0x10002, 0x6209 },
+	{ 0x100b2, 0x1 },
+	{ 0x101b4, 0x1 },
+	{ 0x102b4, 0x1 },
+	{ 0x103b4, 0x1 },
+	{ 0x104b4, 0x1 },
+	{ 0x105b4, 0x1 },
+	{ 0x106b4, 0x1 },
+	{ 0x107b4, 0x1 },
+	{ 0x108b4, 0x1 },
+	{ 0x11011, 0x1 },
+	{ 0x11012, 0x1 },
+	{ 0x11013, 0x180 },
+	{ 0x11018, 0x1 },
+	{ 0x11002, 0x6209 },
+	{ 0x110b2, 0x1 },
+	{ 0x111b4, 0x1 },
+	{ 0x112b4, 0x1 },
+	{ 0x113b4, 0x1 },
+	{ 0x114b4, 0x1 },
+	{ 0x115b4, 0x1 },
+	{ 0x116b4, 0x1 },
+	{ 0x117b4, 0x1 },
+	{ 0x118b4, 0x1 },
+	{ 0x12011, 0x1 },
+	{ 0x12012, 0x1 },
+	{ 0x12013, 0x180 },
+	{ 0x12018, 0x1 },
+	{ 0x12002, 0x6209 },
+	{ 0x120b2, 0x1 },
+	{ 0x121b4, 0x1 },
+	{ 0x122b4, 0x1 },
+	{ 0x123b4, 0x1 },
+	{ 0x124b4, 0x1 },
+	{ 0x125b4, 0x1 },
+	{ 0x126b4, 0x1 },
+	{ 0x127b4, 0x1 },
+	{ 0x128b4, 0x1 },
+	{ 0x13011, 0x1 },
+	{ 0x13012, 0x1 },
+	{ 0x13013, 0x180 },
+	{ 0x13018, 0x1 },
+	{ 0x13002, 0x6209 },
+	{ 0x130b2, 0x1 },
+	{ 0x131b4, 0x1 },
+	{ 0x132b4, 0x1 },
+	{ 0x133b4, 0x1 },
+	{ 0x134b4, 0x1 },
+	{ 0x135b4, 0x1 },
+	{ 0x136b4, 0x1 },
+	{ 0x137b4, 0x1 },
+	{ 0x138b4, 0x1 },
+	{ 0x20089, 0x1 },
+	{ 0x20088, 0x19 },
+	{ 0xc0080, 0x2 },
+	{ 0xd0000, 0x1 }
+};
+
+struct dram_fsp_msg ddr_dram_fsp_msg[] = {
+	{
+		/* P0 3000mts 1D */
+		.drate = 3000,
+		.fw_type = FW_1D_IMAGE,
+		.fsp_cfg = ddr_fsp0_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr_fsp0_cfg),
+	},
+	{
+		/* P1 400mts 1D */
+		.drate = 400,
+		.fw_type = FW_1D_IMAGE,
+		.fsp_cfg = ddr_fsp1_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr_fsp1_cfg),
+	},
+	{
+		/* P2 100mts 1D */
+		.drate = 100,
+		.fw_type = FW_1D_IMAGE,
+		.fsp_cfg = ddr_fsp2_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr_fsp2_cfg),
+	},
+	{
+		/* P0 3000mts 2D */
+		.drate = 3000,
+		.fw_type = FW_2D_IMAGE,
+		.fsp_cfg = ddr_fsp0_2d_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr_fsp0_2d_cfg),
+	},
+};
+
+/* ddr timing config params */
+struct dram_timing_info dram_timing = {
+	.ddrc_cfg = ddr_ddrc_cfg,
+	.ddrc_cfg_num = ARRAY_SIZE(ddr_ddrc_cfg),
+	.ddrphy_cfg = ddr_ddrphy_cfg,
+	.ddrphy_cfg_num = ARRAY_SIZE(ddr_ddrphy_cfg),
+	.fsp_msg = ddr_dram_fsp_msg,
+	.fsp_msg_num = ARRAY_SIZE(ddr_dram_fsp_msg),
+	.ddrphy_trained_csr = ddr_ddrphy_trained_csr,
+	.ddrphy_trained_csr_num = ARRAY_SIZE(ddr_ddrphy_trained_csr),
+	.ddrphy_pie = ddr_phy_pie,
+	.ddrphy_pie_num = ARRAY_SIZE(ddr_phy_pie),
+	.fsp_table = { 3000, 400, 100, },
+};
+
diff --git a/board/aaeon/srg-im8p/mmc.c b/board/aaeon/srg-im8p/mmc.c
new file mode 100644
index 0000000000..ca7d2f936b
--- /dev/null
+++ b/board/aaeon/srg-im8p/mmc.c
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2018 NXP
+ */
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <linux/errno.h>
+#include <asm/io.h>
+#include <stdbool.h>
+#include <mmc.h>
+
+static int check_mmc_autodetect(void)
+{
+	char *autodetect_str = env_get("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/* This should be defined for each board */
+__weak int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 bootpart;
+	u32 dev_no = mmc_get_env_dev();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	env_set_ulong("mmcdev", dev_no);
+	bootpart = env_get_ulong("bootpart", 10, 1);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp%d rootwait rw",
+		mmc_map_to_kernel_blk(dev_no), bootpart);
+	env_set("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
diff --git a/board/aaeon/srg-im8p/spl.c b/board/aaeon/srg-im8p/spl.c
new file mode 100644
index 0000000000..6068966c74
--- /dev/null
+++ b/board/aaeon/srg-im8p/spl.c
@@ -0,0 +1,281 @@
+/*
+ * Copyright 2021 UWINGS
+ * Copyright 2018-2019 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <cpu_func.h>
+#include <hang.h>
+#include <spl.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/arch/imx8mp_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <power/pmic.h>
+
+#include <power/pca9450.h>
+#include <asm/arch/clock.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <fsl_esdhc_imx.h>
+#include <mmc.h>
+#include <asm/arch/ddr.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int spl_board_boot_device(enum boot_device boot_dev_spl)
+{
+#ifdef CONFIG_SPL_BOOTROM_SUPPORT
+	return BOOT_DEVICE_BOOTROM;
+#else
+	switch (boot_dev_spl) {
+	case SD1_BOOT:
+	case MMC1_BOOT:
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		return BOOT_DEVICE_MMC1;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		return BOOT_DEVICE_MMC2;
+	case QSPI_BOOT:
+		return BOOT_DEVICE_NOR;
+	case USB_BOOT:
+		return BOOT_DEVICE_BOARD;
+	default:
+		return BOOT_DEVICE_NONE;
+	}
+#endif
+}
+
+void spl_dram_init(void)
+{
+	ddr_init(&dram_timing);
+}
+
+#define I2C_PAD_CTRL (PAD_CTL_DSE6 | PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PE)
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX8MP_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX8MP_PAD_I2C1_SCL__GPIO5_IO14 | PC,
+		.gp = IMX_GPIO_NR(5, 14),
+	},
+	.sda = {
+		.i2c_mode = MX8MP_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX8MP_PAD_I2C1_SDA__GPIO5_IO15 | PC,
+		.gp = IMX_GPIO_NR(5, 15),
+	},
+};
+
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(2, 12)
+#define USDHC2_PWR_GPIO IMX_GPIO_NR(2, 19)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_HYS | PAD_CTL_PUE |PAD_CTL_PE | \
+			 PAD_CTL_FSEL2)
+#define USDHC_GPIO_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_DSE1)
+#define USDHC_CD_PAD_CTRL (PAD_CTL_PE |PAD_CTL_PUE |PAD_CTL_HYS | PAD_CTL_DSE4)
+
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX8MP_PAD_NAND_WE_B__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_NAND_WP_B__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_NAND_DATA04__USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_NAND_DATA05__USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_NAND_DATA06__USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_NAND_DATA07__USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_NAND_RE_B__USDHC3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_NAND_CE2_B__USDHC3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_NAND_CE3_B__USDHC3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_NAND_CLE__USDHC3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX8MP_PAD_SD2_CLK__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_SD2_CMD__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_SD2_DATA0__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_SD2_DATA1__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_SD2_DATA2__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_SD2_DATA3__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX8MP_PAD_SD2_RESET_B__GPIO2_IO19 | MUX_PAD_CTRL(USDHC_GPIO_PAD_CTRL),
+	MX8MP_PAD_SD2_CD_B__GPIO2_IO12    | MUX_PAD_CTRL(USDHC_CD_PAD_CTRL),
+};
+
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR, 0, 8},
+};
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			init_clk_usdhc(1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_request(USDHC2_PWR_GPIO, "usdhc2_reset");
+			gpio_direction_output(USDHC2_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			gpio_request(USDHC2_CD_GPIO, "usdhc2 cd");
+			gpio_direction_input(USDHC2_CD_GPIO);
+			break;
+		case 1:
+			init_clk_usdhc(2);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC3_BASE_ADDR:
+		ret = 1;
+		break;
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		return ret;
+	}
+
+	return 1;
+}
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+
+	ret = power_pca9450b_init(I2C_PMIC);
+	if (ret)
+		printf("power init failed");
+	p = pmic_get("PCA9450");
+	pmic_probe(p);
+
+	/* BUCKxOUT_DVS0/1 control BUCK123 output */
+	pmic_reg_write(p, PCA9450_BUCK123_DVS, 0x29);
+
+	/*
+	 * increase VDD_SOC to typical value 0.95V before first
+	 * DRAM access, set DVS1 to 0.85v for suspend.
+	 * Enable DVS control through PMIC_STBY_REQ and
+	 * set B1_ENMODE=1 (ON by PMIC_ON_REQ=H)
+	 */
+#ifdef CONFIG_IMX8M_VDD_SOC_850MV
+	/* set DVS0 to 0.85v for special case*/
+	pmic_reg_write(p, PCA9450_BUCK1OUT_DVS0, 0x14);
+#else
+	pmic_reg_write(p, PCA9450_BUCK1OUT_DVS0, 0x1C);
+#endif
+	pmic_reg_write(p, PCA9450_BUCK1OUT_DVS1, 0x14);
+	pmic_reg_write(p, PCA9450_BUCK1CTRL, 0x59);
+
+	/* Kernel uses OD/OD freq for SOC */
+	/* To avoid timing risk from SOC to ARM,increase VDD_ARM to OD voltage 0.95v */
+	pmic_reg_write(p, PCA9450_BUCK2OUT_DVS0, 0x1C);
+
+
+	/* set WDOG_B_CFG to cold reset */
+	pmic_reg_write(p, PCA9450_RESET_CTRL, 0xA1);
+
+	return 0;
+}
+#endif
+
+void spl_board_init(void)
+{
+	/* Set GIC clock to 500Mhz for OD VDD_SOC. Kernel driver does not allow to change it.
+	 * Should set the clock after PMIC setting done.
+	 * Default is 400Mhz (system_pll1_800m with div = 2) set by ROM for ND VDD_SOC
+	 */
+
+	clock_enable(CCGR_GIC, 0);
+	clock_set_target_val(GIC_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(5));
+	clock_enable(CCGR_GIC, 1);
+
+	puts("Normal Boot\n");
+}
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	/* Just empty function now - can't decide what to choose */
+	debug("%s: %s\n", __func__, name);
+
+	return 0;
+}
+#endif
+
+void board_init_f(ulong dummy)
+{
+	int ret;
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	arch_cpu_init();
+
+	board_early_init_f();
+
+	timer_init();
+
+	preloader_console_init();
+
+	ret = spl_init();
+	if (ret) {
+		debug("spl_init() failed: %d\n", ret);
+		hang();
+	}
+
+	enable_tzc380();
+
+	/* Adjust pmic voltage to 1.0V for 800M */
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+
+	power_init_board();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	board_init_r(NULL, 0);
+}
+
+int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	puts("resetting ...\n");
+
+	reset_cpu(WDOG1_BASE_ADDR);
+
+	return 0;
+}
diff --git a/board/aaeon/srg-im8p/srg-im8p.c b/board/aaeon/srg-im8p/srg-im8p.c
new file mode 100644
index 0000000000..f1704c351a
--- /dev/null
+++ b/board/aaeon/srg-im8p/srg-im8p.c
@@ -0,0 +1,361 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2021 Sparktech
+ * Copyright 2021 UWings
+ *
+ * Copyright 2019 NXP
+ *
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm-generic/gpio.h>
+#include <asm/arch/imx8mp_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/arch/clock.h>
+#include <spl.h>
+#include <asm/mach-imx/dma.h>
+#include <power/pmic.h>
+#include <usb.h>
+#include <dwc3-uboot.h>
+#include <mmc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_FSEL1)
+#define WDOG_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_ODE | PAD_CTL_PUE | PAD_CTL_PE)
+
+static iomux_v3_cfg_t const uart_pads[] = {
+	MX8MP_PAD_UART2_RXD__UART2_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX8MP_PAD_UART2_TXD__UART2_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX8MP_PAD_GPIO1_IO02__WDOG1_WDOG_B  | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+};
+
+int board_early_init_f(void)
+{
+	struct wdog_regs *wdog = (struct wdog_regs *)WDOG1_BASE_ADDR;
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset(wdog);
+
+	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
+
+	init_uart_clk(1);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+#define FEC_RST_PAD IMX_GPIO_NR(4, 2)
+static iomux_v3_cfg_t const fec1_rst_pads[] = {
+	MX8MP_PAD_SAI1_RXD0__GPIO4_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_rst_pads,
+					 ARRAY_SIZE(fec1_rst_pads));
+
+	gpio_request(FEC_RST_PAD, "fec1_rst");
+	gpio_direction_output(FEC_RST_PAD, 0);
+	mdelay(15);
+	gpio_direction_output(FEC_RST_PAD, 1);
+	mdelay(100);
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *gpr =
+		(struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+
+	setup_iomux_fec();
+
+	/* Enable RGMII TX clk output */
+	setbits_le32(&gpr->gpr[1], BIT(22));
+
+	//return set_clk_enet(ENET_125MHZ);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_DWC_ETH_QOS
+
+#define EQOS_RST_PAD IMX_GPIO_NR(4, 22)
+static iomux_v3_cfg_t const eqos_rst_pads[] = {
+	MX8MP_PAD_SAI2_RXC__GPIO4_IO22 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_eqos(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eqos_rst_pads,
+					 ARRAY_SIZE(eqos_rst_pads));
+
+	gpio_request(EQOS_RST_PAD, "eqos_rst");
+	gpio_direction_output(EQOS_RST_PAD, 0);
+	mdelay(15);
+	gpio_direction_output(EQOS_RST_PAD, 1);
+	mdelay(100);
+}
+
+static int setup_eqos(void)
+{
+	struct iomuxc_gpr_base_regs *gpr =
+		(struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+
+	setup_iomux_eqos();
+
+	/* set INTF as RGMII, enable RGMII TXC clock */
+	clrsetbits_le32(&gpr->gpr[1],
+			IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_MASK, BIT(16));
+	setbits_le32(&gpr->gpr[1], BIT(19) | BIT(21));
+
+	return set_clk_eqos(ENET_125MHZ);
+}
+#endif
+
+#if defined(CONFIG_FEC_MXC) || defined(CONFIG_DWC_ETH_QOS)
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+	return 0;
+}
+#endif
+
+
+#ifdef CONFIG_USB_DWC3
+
+#define USB_PHY_CTRL0			0xF0040
+#define USB_PHY_CTRL0_REF_SSP_EN	BIT(2)
+
+#define USB_PHY_CTRL1			0xF0044
+#define USB_PHY_CTRL1_RESET		BIT(0)
+#define USB_PHY_CTRL1_COMMONONN		BIT(1)
+#define USB_PHY_CTRL1_ATERESET		BIT(3)
+#define USB_PHY_CTRL1_VDATSRCENB0	BIT(19)
+#define USB_PHY_CTRL1_VDATDETENB0	BIT(20)
+
+#define USB_PHY_CTRL2			0xF0048
+#define USB_PHY_CTRL2_TXENABLEN0	BIT(8)
+
+#define USB_PHY_CTRL6			0xF0058
+
+#define HSIO_GPR_BASE                               (0x32F10000U)
+#define HSIO_GPR_REG_0                              (HSIO_GPR_BASE)
+#define HSIO_GPR_REG_0_USB_CLOCK_MODULE_EN_SHIFT    (1)
+#define HSIO_GPR_REG_0_USB_CLOCK_MODULE_EN          (0x1U << HSIO_GPR_REG_0_USB_CLOCK_MODULE_EN_SHIFT)
+
+
+static struct dwc3_device dwc3_device_data = {
+#ifdef CONFIG_SPL_BUILD
+	.maximum_speed = USB_SPEED_HIGH,
+#else
+	.maximum_speed = USB_SPEED_SUPER,
+#endif
+	.base = USB1_BASE_ADDR,
+	.dr_mode = USB_DR_MODE_PERIPHERAL,
+	.index = 0,
+	.power_down_scale = 2,
+};
+
+int usb_gadget_handle_interrupts(void)
+{
+	dwc3_uboot_handle_interrupt(0);
+	return 0;
+}
+
+static void dwc3_nxp_usb_phy_init(struct dwc3_device *dwc3)
+{
+	u32 RegData;
+
+	/* enable usb clock via hsio gpr */
+	RegData = readl(HSIO_GPR_REG_0);
+	RegData |= HSIO_GPR_REG_0_USB_CLOCK_MODULE_EN;
+	writel(RegData, HSIO_GPR_REG_0);
+
+	/* USB3.0 PHY signal fsel for 100M ref */
+	RegData = readl(dwc3->base + USB_PHY_CTRL0);
+	RegData = (RegData & 0xfffff81f) | (0x2a<<5);
+	writel(RegData, dwc3->base + USB_PHY_CTRL0);
+
+	RegData = readl(dwc3->base + USB_PHY_CTRL6);
+	RegData &=~0x1;
+	writel(RegData, dwc3->base + USB_PHY_CTRL6);
+
+	RegData = readl(dwc3->base + USB_PHY_CTRL1);
+	RegData &= ~(USB_PHY_CTRL1_VDATSRCENB0 | USB_PHY_CTRL1_VDATDETENB0 |
+			USB_PHY_CTRL1_COMMONONN);
+	RegData |= USB_PHY_CTRL1_RESET | USB_PHY_CTRL1_ATERESET;
+	writel(RegData, dwc3->base + USB_PHY_CTRL1);
+
+	RegData = readl(dwc3->base + USB_PHY_CTRL0);
+	RegData |= USB_PHY_CTRL0_REF_SSP_EN;
+	writel(RegData, dwc3->base + USB_PHY_CTRL0);
+
+	RegData = readl(dwc3->base + USB_PHY_CTRL2);
+	RegData |= USB_PHY_CTRL2_TXENABLEN0;
+	writel(RegData, dwc3->base + USB_PHY_CTRL2);
+
+	RegData = readl(dwc3->base + USB_PHY_CTRL1);
+	RegData &= ~(USB_PHY_CTRL1_RESET | USB_PHY_CTRL1_ATERESET);
+	writel(RegData, dwc3->base + USB_PHY_CTRL1);
+}
+#endif
+
+#if defined(CONFIG_USB_DWC3) || defined(CONFIG_USB_XHCI_IMX8M)
+#define USB1_PWR_EN IMX_GPIO_NR(1, 5)
+#define USB2_PWR_EN IMX_GPIO_NR(1, 6)
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	int ret = 0;
+	imx8m_usb_power(index, true);
+
+	if (index == 0 && init == USB_INIT_DEVICE) {
+		dwc3_nxp_usb_phy_init(&dwc3_device_data);
+		return dwc3_uboot_init(&dwc3_device_data);
+	} else if (index == 0 && init == USB_INIT_HOST) {
+		return ret;
+	} else if (index == 1 && init == USB_INIT_HOST) {
+		/* Enable GPIO1_IO05 for 5V VBUS */
+		gpio_request(USB2_PWR_EN, "usb2_pwr");
+		gpio_direction_output(USB2_PWR_EN, 0);
+		gpio_request(USB1_PWR_EN, "usb1_pwr");
+		gpio_direction_output(USB1_PWR_EN, 0);
+	}
+
+	return 0;
+}
+
+int board_usb_cleanup(int index, enum usb_init_type init)
+{
+	int ret = 0;
+	if (index == 0 && init == USB_INIT_DEVICE) {
+		dwc3_uboot_exit(index);
+	} else if (index == 0 && init == USB_INIT_HOST) {
+
+	} else if (index == 1 && init == USB_INIT_HOST) {
+		/* Disable GPIO1_IO05 for 5V VBUS */
+		gpio_direction_output(USB2_PWR_EN, 1);
+		gpio_direction_output(USB1_PWR_EN, 1);
+	}
+
+	imx8m_usb_power(index, false);
+
+	return ret;
+}
+
+#endif
+
+#define TPM_RST IMX_GPIO_NR(1, 15)
+void setup_tpm(void)
+{
+	gpio_request(TPM_RST, "tpm_rst");
+	gpio_direction_output(TPM_RST, 0);
+	mdelay(15);
+	gpio_direction_output(TPM_RST, 1);
+	mdelay(100);
+}
+
+#define FSL_SIP_GPC			0xC2000000
+#define FSL_SIP_CONFIG_GPC_PM_DOMAIN	0x3
+#define DISPMIX				13
+#define MIPI				15
+
+int board_init(void)
+{
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_DWC_ETH_QOS
+	/* clock, pin, gpr */
+	setup_eqos();
+#endif
+
+#if defined(CONFIG_USB_DWC3) || defined(CONFIG_USB_XHCI_IMX8M)
+	init_usb_clk();
+#endif
+
+#ifdef CONFIG_TPM
+	setup_tpm();
+#endif
+	/* enable the dispmix & mipi phy power domain */
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN, DISPMIX, true, 0);
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN, MIPI, true, 0);
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	env_set("board_name", CONFIG_SYS_BOARD_NAME);
+	env_set("board_rev", CONFIG_SYS_BOARD_REV);
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_IMX_BOOTAUX
+ulong board_get_usable_ram_top(ulong total_size)
+{
+	/* Reserve 16M memory used by M core vring/buffer, which begins at 16MB before optee */
+	if (rom_pointer[1])
+		return gd->ram_top - SZ_16M;
+
+	return gd->ram_top;
+}
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#ifdef CONFIG_ANDROID_RECOVERY
+int is_recovery_key_pressing(void)
+{
+	return 0; /*TODO*/
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+#ifdef CONFIG_ANDROID_SUPPORT
+bool is_power_key_pressed(void) {
+	return (bool)(!!(readl(SNVS_HPSR) & (0x1 << 6)));
+}
+#endif
+
+#ifdef CONFIG_SPL_MMC_SUPPORT
+
+#define UBOOT_RAW_SECTOR_OFFSET 0x40
+unsigned long spl_mmc_get_uboot_raw_sector(struct mmc *mmc)
+{
+	u32 boot_dev = spl_boot_device();
+	switch (boot_dev) {
+		case BOOT_DEVICE_MMC2:
+			return CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR - UBOOT_RAW_SECTOR_OFFSET;
+		default:
+			return CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR;
+	}
+}
+#endif
diff --git a/board/freescale/common/mmc.c b/board/freescale/common/mmc.c
index d886808dba..ca7d2f936b 100644
--- a/board/freescale/common/mmc.c
+++ b/board/freescale/common/mmc.c
@@ -32,16 +32,18 @@ void board_late_mmc_env_init(void)
 {
 	char cmd[32];
 	char mmcblk[32];
+	u32 bootpart;
 	u32 dev_no = mmc_get_env_dev();
 
 	if (!check_mmc_autodetect())
 		return;
 
 	env_set_ulong("mmcdev", dev_no);
+	bootpart = env_get_ulong("bootpart", 10, 1);
 
 	/* Set mmcblk env */
-	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
-		mmc_map_to_kernel_blk(dev_no));
+	sprintf(mmcblk, "/dev/mmcblk%dp%d rootwait rw",
+		mmc_map_to_kernel_blk(dev_no), bootpart);
 	env_set("mmcroot", mmcblk);
 
 	sprintf(cmd, "mmc dev %d", dev_no);
diff --git a/cmd/Kconfig b/cmd/Kconfig
index 60d42073aa..31d4fb761f 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -399,6 +399,7 @@ config CMD_ABOOTIMG
 config CMD_ELF
 	bool "bootelf, bootvx"
 	default y
+	select LIB_ELF
 	help
 	  Boot an ELF/vxWorks image from the memory.
 
@@ -778,11 +779,13 @@ config CMD_LZMADEC
 config CMD_UNZIP
 	bool "unzip"
 	default y if CMD_BOOTI
+	select GZIP
 	help
 	  Uncompress a zip-compressed memory region.
 
 config CMD_ZIP
 	bool "zip"
+	select GZIP_COMPRESSED
 	help
 	  Compress a memory region with zlib deflate method.
 
@@ -799,7 +802,7 @@ config CMD_ARMFLASH
 config CMD_ADC
 	bool "adc - Access Analog to Digital Converters info and data"
 	select ADC
-	select DM_REGULATOR
+	depends on DM_REGULATOR
 	help
 	  Shows ADC device info and permit printing one-shot analog converted
 	  data from a named Analog to Digital Converter.
@@ -2009,6 +2012,12 @@ config CMD_FAT
 	help
 	  Support for the FAT fs
 
+config CMD_SQUASHFS
+	bool "SquashFS command support"
+	select FS_SQUASHFS
+	help
+	  Enables SquashFS filesystem commands (e.g. load, ls).
+
 config CMD_FS_GENERIC
 	bool "filesystem commands"
 	help
diff --git a/cmd/Makefile b/cmd/Makefile
index 0d16af5353..f9c9d666d7 100644
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -61,6 +61,7 @@ obj-$(CONFIG_CMD_EXT2) += ext2.o
 obj-$(CONFIG_CMD_FAT) += fat.o
 obj-$(CONFIG_CMD_FDT) += fdt.o
 obj-$(CONFIG_CMD_FITUPD) += fitupd.o
+obj-$(CONFIG_CMD_SQUASHFS) += sqfs.o
 obj-$(CONFIG_CMD_FLASH) += flash.o
 obj-$(CONFIG_CMD_FPGA) += fpga.o
 obj-$(CONFIG_CMD_FPGAD) += fpgad.o
diff --git a/cmd/bootm.c b/cmd/bootm.c
index 03ea3b8998..9f5f2d39ab 100644
--- a/cmd/bootm.c
+++ b/cmd/bootm.c
@@ -177,6 +177,15 @@ int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		/* Do this authentication in boota command */
 		break;
 #endif
+#ifdef CONFIG_FIT
+	case IMAGE_FORMAT_FIT:
+		if (authenticate_image(image_load_addr,
+			image_get_image_size((image_header_t *)image_load_addr)) != 0) {
+			printf("Authenticate FIT image Fail, Please check\n");
+			return 1;
+		}
+		break;
+ #endif
 	default:
 		printf("Not valid image format for Authentication, Please check\n");
 		return 1;
diff --git a/cmd/mmc.c b/cmd/mmc.c
index 1860a3f2e5..3b1244cff0 100644
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -7,6 +7,7 @@
 #include <common.h>
 #include <command.h>
 #include <console.h>
+#include <memalign.h>
 #include <mmc.h>
 #include <sparse_format.h>
 #include <image-sparse.h>
@@ -54,6 +55,9 @@ static void print_mmcinfo(struct mmc *mmc)
 	if (!IS_SD(mmc) && mmc->version >= MMC_VERSION_4_41) {
 		bool has_enh = (mmc->part_support & ENHNCD_SUPPORT) != 0;
 		bool usr_enh = has_enh && (mmc->part_attr & EXT_CSD_ENH_USR);
+		ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+		u8 wp;
+		int ret;
 
 #if CONFIG_IS_ENABLED(MMC_HW_PARTITIONING)
 		puts("HC WP Group Size: ");
@@ -90,6 +94,28 @@ static void print_mmcinfo(struct mmc *mmc)
 					putc('\n');
 			}
 		}
+		ret = mmc_send_ext_csd(mmc, ext_csd);
+		if (ret)
+			return;
+		wp = ext_csd[EXT_CSD_BOOT_WP_STATUS];
+		for (i = 0; i < 2; ++i) {
+			printf("Boot area %d is ", i);
+			switch (wp & 3) {
+			case 0:
+				printf("not write protected\n");
+				break;
+			case 1:
+				printf("power on protected\n");
+				break;
+			case 2:
+				printf("permanently protected\n");
+				break;
+			default:
+				printf("in reserved protection state\n");
+				break;
+			}
+			wp >>= 2;
+		}
 	}
 }
 static struct mmc *init_mmc_device(int dev, bool force_init)
@@ -872,9 +898,30 @@ static int do_mmc_bkops_enable(cmd_tbl_t *cmdtp, int flag,
 }
 #endif
 
+static int do_mmc_boot_wp(cmd_tbl_t *cmdtp, int flag,
+			  int argc, char * const argv[])
+{
+	int err;
+	struct mmc *mmc;
+
+	mmc = init_mmc_device(curr_device, false);
+	if (!mmc)
+		return CMD_RET_FAILURE;
+	if (IS_SD(mmc)) {
+		printf("It is not an eMMC device\n");
+		return CMD_RET_FAILURE;
+	}
+	err = mmc_boot_wp(mmc);
+	if (err)
+		return CMD_RET_FAILURE;
+	printf("boot areas protected\n");
+	return CMD_RET_SUCCESS;
+}
+
 static cmd_tbl_t cmd_mmc[] = {
 	U_BOOT_CMD_MKENT(info, 1, 0, do_mmcinfo, "", ""),
 	U_BOOT_CMD_MKENT(read, 4, 1, do_mmc_read, "", ""),
+	U_BOOT_CMD_MKENT(wp, 1, 0, do_mmc_boot_wp, "", ""),
 #if CONFIG_IS_ENABLED(MMC_WRITE)
 	U_BOOT_CMD_MKENT(write, 4, 0, do_mmc_write, "", ""),
 	U_BOOT_CMD_MKENT(erase, 3, 0, do_mmc_erase, "", ""),
@@ -944,6 +991,7 @@ U_BOOT_CMD(
 	"mmc part - lists available partition on current mmc device\n"
 	"mmc dev [dev] [part] - show or set current mmc device [partition]\n"
 	"mmc list - lists available devices\n"
+	"mmc wp - power on write protect boot partitions\n"
 #if CONFIG_IS_ENABLED(MMC_HW_PARTITIONING)
 	"mmc hwpartition [args...] - does hardware partitioning\n"
 	"  arguments (sizes in 512-byte blocks):\n"
@@ -954,13 +1002,13 @@ U_BOOT_CMD(
 	"  Power cycling is required to initialize partitions after set to complete.\n"
 #endif
 #ifdef CONFIG_SUPPORT_EMMC_BOOT
-	"mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode\n"
+	"mmc bootbus <dev> <boot_bus_width> <reset_boot_bus_width> <boot_mode>\n"
 	" - Set the BOOT_BUS_WIDTH field of the specified device\n"
 	"mmc bootpart-resize <dev> <boot part size MB> <RPMB part size MB>\n"
 	" - Change sizes of boot and RPMB partitions of specified device\n"
-	"mmc partconf dev [boot_ack boot_partition partition_access]\n"
+	"mmc partconf <dev> [boot_ack boot_partition partition_access]\n"
 	" - Show or change the bits of the PARTITION_CONFIG field of the specified device\n"
-	"mmc rst-function dev value\n"
+	"mmc rst-function <dev> <value>\n"
 	" - Change the RST_n_FUNCTION field of the specified device\n"
 	"   WARNING: This is a write-once field and 0 / 1 / 2 are the only valid values.\n"
 #endif
diff --git a/cmd/sqfs.c b/cmd/sqfs.c
new file mode 100644
index 0000000000..2246174df2
--- /dev/null
+++ b/cmd/sqfs.c
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ *
+ * squashfs.c:	implements SquashFS related commands
+ */
+
+#include <command.h>
+#include <fs.h>
+#include <squashfs.h>
+
+static int do_sqfs_ls(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	return do_ls(cmdtp, flag, argc, argv, FS_TYPE_SQUASHFS);
+}
+
+U_BOOT_CMD(sqfsls, 4, 1, do_sqfs_ls,
+	   "List files in directory. Default: root (/).",
+	   "<interface> [<dev[:part]>] [directory]\n"
+	   "    - list files from 'dev' on 'interface' in 'directory'\n"
+);
+
+static int do_sqfs_load(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	return do_load(cmdtp, flag, argc, argv, FS_TYPE_SQUASHFS);
+}
+
+U_BOOT_CMD(sqfsload, 7, 0, do_sqfs_load,
+	   "load binary file from a SquashFS filesystem",
+	   "<interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]\n"
+	   "    - Load binary file 'filename' from 'dev' on 'interface'\n"
+	   "      to address 'addr' from SquashFS filesystem.\n"
+	   "      'pos' gives the file position to start loading from.\n"
+	   "      If 'pos' is omitted, 0 is used. 'pos' requires 'bytes'.\n"
+	   "      'bytes' gives the size to load. If 'bytes' is 0 or omitted,\n"
+	   "      the load stops on end of file.\n"
+	   "      If either 'pos' or 'bytes' are not aligned to\n"
+	   "      ARCH_DMA_MINALIGN then a misaligned buffer warning will\n"
+	   "      be printed and performance will suffer for the load."
+);
diff --git a/configs/imx8mp_evk_defconfig b/configs/imx8mp_evk_defconfig
index 82d1281f5b..151d732012 100644
--- a/configs/imx8mp_evk_defconfig
+++ b/configs/imx8mp_evk_defconfig
@@ -10,9 +10,12 @@ CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_SYS_I2C_MXC_I2C1=y
 CONFIG_SYS_I2C_MXC_I2C2=y
 CONFIG_SYS_I2C_MXC_I2C3=y
-CONFIG_ENV_SIZE=0x1000
+CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
+CONFIG_ENV_SIZE=0x4000
 CONFIG_ENV_OFFSET=0x400000
 CONFIG_ENV_SECT_SIZE=0x10000
+CONFIG_ENV_OFFSET_REDUND=0x410000
+CONFIG_ENV_SIZE_REDUND=0x4000
 CONFIG_DM_GPIO=y
 CONFIG_TARGET_IMX8MP_EVK=y
 CONFIG_ARCH_MISC_INIT=y
diff --git a/configs/srg-im8p_defconfig b/configs/srg-im8p_defconfig
new file mode 100644
index 0000000000..f44826d3fb
--- /dev/null
+++ b/configs/srg-im8p_defconfig
@@ -0,0 +1,181 @@
+CONFIG_ARM=y
+CONFIG_SPL_SYS_ICACHE_OFF=y
+CONFIG_SPL_SYS_DCACHE_OFF=y
+CONFIG_ARCH_IMX8M=y
+CONFIG_SYS_TEXT_BASE=0x40200000
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SYS_I2C_MXC_I2C1=y
+CONFIG_SYS_I2C_MXC_I2C2=y
+CONFIG_SYS_I2C_MXC_I2C3=y
+CONFIG_ENV_SIZE=0x8000
+CONFIG_ENV_SECT_SIZE=0x10000
+CONFIG_ENV_OFFSET=0x400000
+CONFIG_DM_GPIO=y
+CONFIG_TARGET_SRG_IM8P=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
+CONFIG_NR_DRAM_BANKS=2
+CONFIG_SPL=y
+CONFIG_ENV_OFFSET_REDUND=0x410000
+CONFIG_CSF_SIZE=0x2000
+# CONFIG_CMD_DEKBLOB is not set
+CONFIG_SPL_IMX_ROMAPI_LOADADDR=0x48000000
+CONFIG_SPL_TEXT_BASE=0x920000
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_BOOTCOMMAND="run distro_bootcmd;run bsp_bootcmd"
+CONFIG_FIT=y
+CONFIG_FIT_EXTERNAL_OFFSET=0x3000
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_SPL_FIT_GENERATOR="arch/arm/mach-imx/mkimage_fit_atf.sh"
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/mach-imx/imx8m/imximage-8mp-lpddr4.cfg"
+CONFIG_SILENT_CONSOLE=y
+CONFIG_DEFAULT_FDT_FILE="/boot/srg-im8p.dtb"
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_BOOTROM_SUPPORT=y
+CONFIG_SPL_SEPARATE_BSS=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_POWER_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="u-boot=> "
+# CONFIG_BOOTM_NETBSD is not set
+# CONFIG_CMD_EXPORTENV is not set
+# CONFIG_CMD_IMPORTENV is not set
+CONFIG_CMD_ERASEENV=y
+# CONFIG_CMD_CRC32 is not set
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_REGULATOR=y
+# CONFIG_CMD_HASH is not set
+CONFIG_CMD_TPM=y
+CONFIG_CMD_TPM_TEST=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_SQUASHFS=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_USB=y
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="srg-im8p"
+CONFIG_ENV_IS_NOWHERE=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_BOOTCOUNT_LIMIT=y
+CONFIG_BOOTCOUNT_ENV=y
+CONFIG_CLK_COMPOSITE_CCF=y
+CONFIG_CLK_IMX8MP=y
+
+CONFIG_FASTBOOT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_CMD_FASTBOOT=y
+CONFIG_ANDROID_BOOT_IMAGE=y
+CONFIG_FASTBOOT_UUU_SUPPORT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x42800000
+CONFIG_FASTBOOT_BUF_SIZE=0x40000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_MXC_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MXC=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_DM_MMC=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_ES_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_EFI_PARTITION=y
+
+CONFIG_FSL_ESDHC_IMX=y
+CONFIG_DM_SPI_FLASH=y
+
+
+
+CONFIG_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0
+CONFIG_SF_DEFAULT_SPEED=40000000
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SF_DEFAULT_BUS=0
+CONFIG_SF_DEFAULT_CS=0
+
+CONFIG_DM_ETH=y
+# CONFIG_DM_ETH_PHY=y
+CONFIG_DWC_ETH_QOS=y
+
+CONFIG_PHY_GIGE=y
+CONFIG_FEC_MXC=y
+CONFIG_MII=y
+CONFIG_RGMII=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_REALTEK=y
+
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX8M=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_MXC_UART=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_SOFT_SPI=y
+CONFIG_FSL_FSPI=y
+CONFIG_SYSRESET=y
+CONFIG_SYSRESET_PSCI=y
+CONFIG_DM_THERMAL=y
+CONFIG_NXP_TMU=y
+CONFIG_USB=y
+
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_XHCI_IMX8M=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_GADGET=y
+
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+CONFIG_USB_GADGET_DOWNLOAD=y
+
+
+
+
+
+
+
+CONFIG_DM_VIDEO=y
+CONFIG_SYS_WHITE_ON_BLACK=y
+CONFIG_VIDEO_LCD_RAYDIUM_RM67191=y
+CONFIG_VIDEO_IMX_SEC_DSI=y
+CONFIG_VIDEO_IMX_LCDIFV3=y
+CONFIG_VIDEO_ADV7535=y
+CONFIG_TPM=y
+# CONFIG_TPM_V1 is not set
+CONFIG_TPM_V2=y
+CONFIG_TPM2_TIS_SPI=y
+CONFIG_ZSTD=y
+CONFIG_OF_LIBFDT_OVERLAY=y
diff --git a/drivers/mmc/fsl_esdhc_imx.c b/drivers/mmc/fsl_esdhc_imx.c
index c85a3cc933..9b6a5a3dcf 100644
--- a/drivers/mmc/fsl_esdhc_imx.c
+++ b/drivers/mmc/fsl_esdhc_imx.c
@@ -682,6 +682,8 @@ static void set_sysctl(struct fsl_esdhc_priv *priv, struct mmc *mmc, uint clock)
 	if (ret)
 		pr_warn("fsl_esdhc_imx: Internal clock never stabilised.\n");
 
+	udelay(1000); /* for improve the compatibility for UHS-1 SD cards */
+
 #ifdef CONFIG_FSL_USDHC
 	esdhc_setbits32(&regs->vendorspec, VENDORSPEC_PEREN | VENDORSPEC_CKEN);
 #else
@@ -959,6 +961,7 @@ static int esdhc_set_ios_common(struct fsl_esdhc_priv *priv, struct mmc *mmc)
 	if (priv->clock != clock)
 		set_sysctl(priv, mmc, clock);
 
+	udelay(1000); /* for improve the compatibility for UHS-1 SD cards */
 #ifdef MMC_SUPPORTS_TUNING
 	if (mmc->clk_disable) {
 #ifdef CONFIG_FSL_USDHC
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index e4259872a5..1ae7cff304 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -726,7 +726,7 @@ static int mmc_complete_op_cond(struct mmc *mmc)
 }
 
 
-static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
+int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 {
 	struct mmc_cmd cmd;
 	struct mmc_data data;
@@ -818,6 +818,11 @@ int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
 	return __mmc_switch(mmc, set, index, value, true);
 }
 
+int mmc_boot_wp(struct mmc *mmc)
+{
+	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BOOT_WP, 1);
+}
+
 #if !CONFIG_IS_ENABLED(MMC_TINY)
 static int mmc_set_card_speed(struct mmc *mmc, enum bus_mode mode,
 			      bool hsdowngrade)
diff --git a/drivers/tpm/tpm_tis.h b/drivers/tpm/tpm_tis.h
index 947585f8e3..082f2cfc05 100644
--- a/drivers/tpm/tpm_tis.h
+++ b/drivers/tpm/tpm_tis.h
@@ -112,7 +112,7 @@ struct tpm_cmd_t {
  * how long it will take.
  */
 #define MAX_COUNT_LONG		50
-
+/*
 enum tis_access {
 	TPM_ACCESS_VALID		= 0x80,
 	TPM_ACCESS_ACTIVE_LOCALITY	= 0x20,
@@ -127,5 +127,5 @@ enum tis_status {
 	TPM_STS_DATA_AVAIL		= 0x10,
 	TPM_STS_DATA_EXPECT		= 0x08,
 };
-
+*/
 #endif
diff --git a/fs/Kconfig b/fs/Kconfig
index 1cb9831be8..620af7f044 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -22,4 +22,6 @@ source "fs/cramfs/Kconfig"
 
 source "fs/yaffs2/Kconfig"
 
+source "fs/squashfs/Kconfig"
+
 endmenu
diff --git a/fs/Makefile b/fs/Makefile
index 42e669c40c..937cbcf6e8 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_FS_LOADER) += fs.o
 obj-$(CONFIG_SPL_FS_FAT) += fat/
 obj-$(CONFIG_SPL_FS_EXT4) += ext4/
 obj-$(CONFIG_SPL_FS_CBFS) += cbfs/
+obj-$(CONFIG_SPL_FS_SQUASHFS) += squashfs/
 else
 obj-y				+= fs.o
 
@@ -23,5 +24,6 @@ obj-$(CONFIG_SANDBOX) += sandbox/
 obj-$(CONFIG_CMD_UBIFS) += ubifs/
 obj-$(CONFIG_YAFFS2) += yaffs2/
 obj-$(CONFIG_CMD_ZFS) += zfs/
+obj-$(CONFIG_FS_SQUASHFS) += squashfs/
 endif
 obj-y += fs_internal.o
diff --git a/fs/fs.c b/fs/fs.c
index 0c66d60477..047b90c476 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -19,6 +19,7 @@
 #include <div64.h>
 #include <linux/math64.h>
 #include <efi_loader.h>
+#include <squashfs.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -55,6 +56,9 @@ static int fs_ls_generic(const char *dirname)
 		if (dent->type == FS_DT_DIR) {
 			printf("            %s/\n", dent->name);
 			ndirs++;
+		} else if (dent->type == FS_DT_LNK) {
+			printf("    <SYM>   %s\n", dent->name);
+			nfiles++;
 		} else {
 			printf(" %8lld   %s\n", dent->size, dent->name);
 			nfiles++;
@@ -273,6 +277,27 @@ static struct fstype_info fstypes[] = {
 		.mkdir = fs_mkdir_unsupported,
 		.ln = fs_ln_unsupported,
 	},
+#endif
+#if IS_ENABLED(CONFIG_FS_SQUASHFS)
+	{
+		.fstype = FS_TYPE_SQUASHFS,
+		.name = "squashfs",
+		.null_dev_desc_ok = false,
+		.probe = sqfs_probe,
+		.opendir = sqfs_opendir,
+		.readdir = sqfs_readdir,
+		.ls = fs_ls_generic,
+		.read = sqfs_read,
+		.size = sqfs_size,
+		.close = sqfs_close,
+		.closedir = sqfs_closedir,
+		.exists = sqfs_exists,
+		.uuid = fs_uuid_unsupported,
+		.write = fs_write_unsupported,
+		.ln = fs_ln_unsupported,
+		.unlink = fs_unlink_unsupported,
+		.mkdir = fs_mkdir_unsupported,
+	},
 #endif
 	{
 		.fstype = FS_TYPE_ANY,
diff --git a/fs/squashfs/Kconfig b/fs/squashfs/Kconfig
new file mode 100644
index 0000000000..54ab1618f1
--- /dev/null
+++ b/fs/squashfs/Kconfig
@@ -0,0 +1,11 @@
+config FS_SQUASHFS
+	bool "Enable SquashFS filesystem support"
+	select ZLIB_UNCOMPRESS
+	help
+	  This provides support for reading images from SquashFS filesystem.
+	  Squashfs is a compressed read-only filesystem for Linux.
+	  It uses zlib, lz4, lzo, or xz compression to compress files, inodes
+	  and directories. Squashfs is intended for general read-only
+	  filesystem use, for archival use (i.e. in cases where a .tar.gz file
+	  may be used), and in constrained block device/memory systems (e.g.
+	  embedded systems) where low overhead is needed.
diff --git a/fs/squashfs/Makefile b/fs/squashfs/Makefile
new file mode 100644
index 0000000000..ba66ee821c
--- /dev/null
+++ b/fs/squashfs/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+obj-$(CONFIG_$(SPL_)FS_SQUASHFS) = sqfs.o \
+				sqfs_inode.o \
+				sqfs_dir.o \
+				sqfs_decompressor.o
diff --git a/fs/squashfs/sqfs.c b/fs/squashfs/sqfs.c
new file mode 100644
index 0000000000..92ab8ac631
--- /dev/null
+++ b/fs/squashfs/sqfs.c
@@ -0,0 +1,1723 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ *
+ * sqfs.c: SquashFS filesystem implementation
+ */
+
+#include <asm/unaligned.h>
+#include <errno.h>
+#include <fs.h>
+#include <linux/types.h>
+#include <linux/byteorder/little_endian.h>
+#include <linux/byteorder/generic.h>
+#include <memalign.h>
+#include <stdlib.h>
+#include <string.h>
+#include <squashfs.h>
+#include <part.h>
+
+#include "sqfs_decompressor.h"
+#include "sqfs_filesystem.h"
+#include "sqfs_utils.h"
+
+static struct squashfs_ctxt ctxt;
+
+static int sqfs_disk_read(__u32 block, __u32 nr_blocks, void *buf)
+{
+	ulong ret;
+
+	if (!ctxt.cur_dev)
+		return -1;
+
+	ret = blk_dread(ctxt.cur_dev, ctxt.cur_part_info.start + block,
+			nr_blocks, buf);
+
+	if (ret != nr_blocks)
+		return -1;
+
+	return ret;
+}
+
+static int sqfs_read_sblk(struct squashfs_super_block **sblk)
+{
+	*sblk = malloc_cache_aligned(ctxt.cur_dev->blksz);
+	if (!*sblk)
+		return -ENOMEM;
+
+	if (sqfs_disk_read(0, 1, *sblk) != 1) {
+		free(*sblk);
+		sblk = NULL;
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sqfs_count_tokens(const char *filename)
+{
+	int token_count = 1, l;
+
+	for (l = 1; l < strlen(filename); l++) {
+		if (filename[l] == '/')
+			token_count++;
+	}
+
+	/* Ignore trailing '/' in path */
+	if (filename[strlen(filename) - 1] == '/')
+		token_count--;
+
+	if (!token_count)
+		token_count = 1;
+
+	return token_count;
+}
+
+/*
+ * Calculates how many blocks are needed for the buffer used in sqfs_disk_read.
+ * The memory section (e.g. inode table) start offset and its end (i.e. the next
+ * table start) must be specified. It also calculates the offset from which to
+ * start reading the buffer.
+ */
+static int sqfs_calc_n_blks(__le64 start, __le64 end, u64 *offset)
+{
+	u64 start_, table_size;
+
+	table_size = le64_to_cpu(end) - le64_to_cpu(start);
+	start_ = le64_to_cpu(start) / ctxt.cur_dev->blksz;
+	*offset = le64_to_cpu(start) - (start_ * ctxt.cur_dev->blksz);
+
+	return DIV_ROUND_UP(table_size + *offset, ctxt.cur_dev->blksz);
+}
+
+/*
+ * Retrieves fragment block entry and returns true if the fragment block is
+ * compressed
+ */
+static int sqfs_frag_lookup(u32 inode_fragment_index,
+			    struct squashfs_fragment_block_entry *e)
+{
+	u64 start, n_blks, src_len, table_offset, start_block;
+	unsigned char *metadata_buffer, *metadata, *table;
+	struct squashfs_fragment_block_entry *entries;
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	unsigned long dest_len;
+	int block, offset, ret;
+	u16 header;
+
+	metadata_buffer = NULL;
+	entries = NULL;
+	table = NULL;
+
+	if (inode_fragment_index >= get_unaligned_le32(&sblk->fragments))
+		return -EINVAL;
+
+	start = get_unaligned_le64(&sblk->fragment_table_start) /
+		ctxt.cur_dev->blksz;
+	n_blks = sqfs_calc_n_blks(sblk->fragment_table_start,
+				  sblk->export_table_start,
+				  &table_offset);
+
+	/* Allocate a proper sized buffer to store the fragment index table */
+	table = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+	if (!table) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (sqfs_disk_read(start, n_blks, table) < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	block = SQFS_FRAGMENT_INDEX(inode_fragment_index);
+	offset = SQFS_FRAGMENT_INDEX_OFFSET(inode_fragment_index);
+
+	/*
+	 * Get the start offset of the metadata block that contains the right
+	 * fragment block entry
+	 */
+	start_block = get_unaligned_le64(table + table_offset + block *
+					 sizeof(u64));
+
+	start = start_block / ctxt.cur_dev->blksz;
+	n_blks = sqfs_calc_n_blks(cpu_to_le64(start_block),
+				  sblk->fragment_table_start, &table_offset);
+
+	metadata_buffer = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+	if (!metadata_buffer) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (sqfs_disk_read(start, n_blks, metadata_buffer) < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Every metadata block starts with a 16-bit header */
+	header = get_unaligned_le16(metadata_buffer + table_offset);
+	metadata = metadata_buffer + table_offset + SQFS_HEADER_SIZE;
+
+	if (!metadata || !header) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	entries = malloc(SQFS_METADATA_BLOCK_SIZE);
+	if (!entries) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (SQFS_COMPRESSED_METADATA(header)) {
+		src_len = SQFS_METADATA_SIZE(header);
+		dest_len = SQFS_METADATA_BLOCK_SIZE;
+		ret = sqfs_decompress(&ctxt, entries, &dest_len, metadata,
+				      src_len);
+		if (ret) {
+			ret = -EINVAL;
+			goto out;
+		}
+	} else {
+		memcpy(entries, metadata, SQFS_METADATA_SIZE(header));
+	}
+
+	*e = entries[offset];
+	ret = SQFS_COMPRESSED_BLOCK(e->size);
+
+out:
+	free(entries);
+	free(metadata_buffer);
+	free(table);
+
+	return ret;
+}
+
+/*
+ * The entry name is a flexible array member, and we don't know its size before
+ * actually reading the entry. So we need a first copy to retrieve this size so
+ * we can finally copy the whole struct.
+ */
+static int sqfs_read_entry(struct squashfs_directory_entry **dest, void *src)
+{
+	struct squashfs_directory_entry *tmp;
+	u16 sz;
+
+	tmp = src;
+	sz = get_unaligned_le16(src + sizeof(*tmp) - sizeof(u16));
+	/*
+	 * 'src' points to the begin of a directory entry, and 'sz' gets its
+	 * 'name_size' member's value. name_size is actually the string
+	 * length - 1, so adding 2 compensates this difference and adds space
+	 * for the trailling null byte.
+	 */
+	*dest = malloc(sizeof(*tmp) + sz + 2);
+	if (!*dest)
+		return -ENOMEM;
+
+	memcpy(*dest, src, sizeof(*tmp) + sz + 1);
+	(*dest)->name[sz + 1] = '\0';
+
+	return 0;
+}
+
+static int sqfs_get_tokens_length(char **tokens, int count)
+{
+	int length = 0, i;
+
+	/*
+	 * 1 is added to the result of strlen to consider the slash separator
+	 * between the tokens.
+	 */
+	for (i = 0; i < count; i++)
+		length += strlen(tokens[i]) + 1;
+
+	return length;
+}
+
+/* Takes a token list and returns a single string with '/' as separator. */
+static char *sqfs_concat_tokens(char **token_list, int token_count)
+{
+	char *result;
+	int i, length = 0, offset = 0;
+
+	length = sqfs_get_tokens_length(token_list, token_count);
+
+	result = malloc(length + 1);
+	if (!result)
+		return NULL;
+
+	result[length] = '\0';
+
+	for (i = 0; i < token_count; i++) {
+		strcpy(result + offset, token_list[i]);
+		offset += strlen(token_list[i]);
+		result[offset++] = '/';
+	}
+
+	return result;
+}
+
+/*
+ * Differently from sqfs_concat_tokens, sqfs_join writes the result into a
+ * previously allocated string, and returns the number of bytes written.
+ */
+static int sqfs_join(char **strings, char *dest, int start, int end,
+		     char separator)
+{
+	int i, offset = 0;
+
+	for (i = start; i < end; i++) {
+		strcpy(dest + offset, strings[i]);
+		offset += strlen(strings[i]);
+		if (i < end - 1)
+			dest[offset++] = separator;
+	}
+
+	return offset;
+}
+
+/*
+ * Fills the given token list using its size (count) and a source string (str)
+ */
+static int sqfs_tokenize(char **tokens, int count, const char *str)
+{
+	int i, j, ret = 0;
+	char *aux, *strc;
+
+	strc = strdup(str);
+	if (!strc)
+		return -ENOMEM;
+
+	if (!strcmp(strc, "/")) {
+		tokens[0] = strdup(strc);
+		if (!tokens[0]) {
+			ret = -ENOMEM;
+			goto free_strc;
+		}
+	} else {
+		for (j = 0; j < count; j++) {
+			aux = strtok(!j ? strc : NULL, "/");
+			tokens[j] = strdup(aux);
+			if (!tokens[j]) {
+				for (i = 0; i < j; i++)
+					free(tokens[i]);
+				ret = -ENOMEM;
+				goto free_strc;
+			}
+		}
+	}
+
+free_strc:
+	free(strc);
+
+	return ret;
+}
+
+/*
+ * Remove last 'updir + 1' tokens from the base path tokens list. This leaves us
+ * with a token list containing only the tokens needed to form the resolved
+ * path, and returns the decremented size of the token list.
+ */
+static int sqfs_clean_base_path(char **base, int count, int updir)
+{
+	int i;
+
+	for (i = count - updir - 1; i < count; i++)
+		free(base[i]);
+
+	return count - updir - 1;
+}
+
+/*
+ * Given the base ("current dir.") path and the relative one, generate the
+ * absolute path.
+ */
+static char *sqfs_get_abs_path(const char *base, const char *rel)
+{
+	char **base_tokens, **rel_tokens, *resolved = NULL;
+	int ret, bc, rc, i, updir = 0, resolved_size = 0, offset = 0;
+
+	base_tokens = NULL;
+	rel_tokens = NULL;
+
+	/* Memory allocation for the token lists */
+	bc = sqfs_count_tokens(base);
+	rc = sqfs_count_tokens(rel);
+	if (bc < 1 || rc < 1)
+		return NULL;
+
+	base_tokens = calloc(bc, sizeof(char *));
+	if (!base_tokens)
+		return NULL;
+
+	rel_tokens = calloc(rc, sizeof(char *));
+	if (!rel_tokens)
+		goto out;
+
+	/* Fill token lists */
+	ret = sqfs_tokenize(base_tokens, bc, base);
+	if (ret)
+		goto out;
+
+	ret = sqfs_tokenize(rel_tokens, rc, rel);
+	if (ret)
+		goto out;
+
+	/* count '..' occurrences in target path */
+	for (i = 0; i < rc; i++) {
+		if (!strcmp(rel_tokens[i], ".."))
+			updir++;
+	}
+
+	/* Remove the last token and the '..' occurrences */
+	bc = sqfs_clean_base_path(base_tokens, bc, updir);
+	if (bc < 0)
+		goto out;
+
+	/* Calculate resolved path size */
+	if (!bc)
+		resolved_size++;
+
+	resolved_size += sqfs_get_tokens_length(base_tokens, bc) +
+		sqfs_get_tokens_length(rel_tokens, rc);
+
+	resolved = malloc(resolved_size + 1);
+	if (!resolved)
+		goto out;
+
+	/* Set resolved path */
+	memset(resolved, '\0', resolved_size + 1);
+	offset += sqfs_join(base_tokens, resolved + offset, 0, bc, '/');
+	resolved[offset++] = '/';
+	offset += sqfs_join(rel_tokens, resolved + offset, updir, rc, '/');
+
+out:
+	if (rel_tokens)
+		for (i = 0; i < rc; i++)
+			free(rel_tokens[i]);
+	if (base_tokens)
+		for (i = 0; i < bc; i++)
+			free(base_tokens[i]);
+
+	free(rel_tokens);
+	free(base_tokens);
+
+	return resolved;
+}
+
+static char *sqfs_resolve_symlink(struct squashfs_symlink_inode *sym,
+				  const char *base_path)
+{
+	char *resolved, *target;
+	u32 sz;
+
+	sz = get_unaligned_le32(&sym->symlink_size);
+	target = malloc(sz + 1);
+	if (!target)
+		return NULL;
+
+	/*
+	 * There is no trailling null byte in the symlink's target path, so a
+	 * copy is made and a '\0' is added at its end.
+	 */
+	target[sz] = '\0';
+	/* Get target name (relative path) */
+	strncpy(target, sym->symlink, sz);
+
+	/* Relative -> absolute path conversion */
+	resolved = sqfs_get_abs_path(base_path, target);
+
+	free(target);
+
+	return resolved;
+}
+
+/*
+ * m_list contains each metadata block's position, and m_count is the number of
+ * elements of m_list. Those metadata blocks come from the compressed directory
+ * table.
+ */
+static int sqfs_search_dir(struct squashfs_dir_stream *dirs, char **token_list,
+			   int token_count, u32 *m_list, int m_count)
+{
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	char *path, *target, **sym_tokens, *res, *rem;
+	int j, ret = 0, new_inode_number, offset;
+	struct squashfs_symlink_inode *sym;
+	struct squashfs_ldir_inode *ldir;
+	struct squashfs_dir_inode *dir;
+	struct fs_dir_stream *dirsp;
+	struct fs_dirent *dent;
+	unsigned char *table;
+
+	res = NULL;
+	rem = NULL;
+	path = NULL;
+	target = NULL;
+	sym_tokens = NULL;
+
+	dirsp = (struct fs_dir_stream *)dirs;
+
+	/* Start by root inode */
+	table = sqfs_find_inode(dirs->inode_table, le32_to_cpu(sblk->inodes),
+				sblk->inodes, sblk->block_size);
+
+	dir = (struct squashfs_dir_inode *)table;
+	ldir = (struct squashfs_ldir_inode *)table;
+
+	/* get directory offset in directory table */
+	offset = sqfs_dir_offset(table, m_list, m_count);
+	dirs->table = &dirs->dir_table[offset];
+
+	/* Setup directory header */
+	dirs->dir_header = malloc(SQFS_DIR_HEADER_SIZE);
+	if (!dirs->dir_header)
+		return -ENOMEM;
+
+	memcpy(dirs->dir_header, dirs->table, SQFS_DIR_HEADER_SIZE);
+
+	/* Initialize squashfs_dir_stream members */
+	dirs->table += SQFS_DIR_HEADER_SIZE;
+	dirs->size = get_unaligned_le16(&dir->file_size) - SQFS_DIR_HEADER_SIZE;
+	dirs->entry_count = dirs->dir_header->count + 1;
+
+	/* No path given -> root directory */
+	if (!strcmp(token_list[0], "/")) {
+		dirs->table = &dirs->dir_table[offset];
+		memcpy(&dirs->i_dir, dir, sizeof(*dir));
+		return 0;
+	}
+
+	for (j = 0; j < token_count; j++) {
+		if (!sqfs_is_dir(get_unaligned_le16(&dir->inode_type))) {
+			printf("** Cannot find directory. **\n");
+			ret = -EINVAL;
+			goto out;
+		}
+
+		while (!sqfs_readdir(dirsp, &dent)) {
+			ret = strcmp(dent->name, token_list[j]);
+			if (!ret)
+				break;
+			free(dirs->entry);
+			dirs->entry = NULL;
+		}
+
+		if (ret) {
+			printf("** Cannot find directory. **\n");
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* Redefine inode as the found token */
+		new_inode_number = dirs->entry->inode_offset +
+			dirs->dir_header->inode_number;
+
+		/* Get reference to inode in the inode table */
+		table = sqfs_find_inode(dirs->inode_table, new_inode_number,
+					sblk->inodes, sblk->block_size);
+		dir = (struct squashfs_dir_inode *)table;
+
+		/* Check for symbolic link and inode type sanity */
+		if (get_unaligned_le16(&dir->inode_type) == SQFS_SYMLINK_TYPE) {
+			sym = (struct squashfs_symlink_inode *)table;
+			/* Get first j + 1 tokens */
+			path = sqfs_concat_tokens(token_list, j + 1);
+			if (!path) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			/* Resolve for these tokens */
+			target = sqfs_resolve_symlink(sym, path);
+			if (!target) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			/* Join remaining tokens */
+			rem = sqfs_concat_tokens(token_list + j + 1, token_count -
+						 j - 1);
+			if (!rem) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			/* Concatenate remaining tokens and symlink's target */
+			res = malloc(strlen(rem) + strlen(target) + 1);
+			if (!res) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			strcpy(res, target);
+			res[strlen(target)] = '/';
+			strcpy(res + strlen(target) + 1, rem);
+			token_count = sqfs_count_tokens(res);
+
+			if (token_count < 0) {
+				ret = -EINVAL;
+				goto out;
+			}
+
+			sym_tokens = malloc(token_count * sizeof(char *));
+			if (!sym_tokens) {
+				ret = -EINVAL;
+				goto out;
+			}
+
+			/* Fill tokens list */
+			ret = sqfs_tokenize(sym_tokens, token_count, res);
+			if (ret) {
+				ret = -EINVAL;
+				goto out;
+			}
+			free(dirs->entry);
+			dirs->entry = NULL;
+
+			ret = sqfs_search_dir(dirs, sym_tokens, token_count,
+					      m_list, m_count);
+			goto out;
+		} else if (!sqfs_is_dir(get_unaligned_le16(&dir->inode_type))) {
+			printf("** Cannot find directory. **\n");
+			free(dirs->entry);
+			dirs->entry = NULL;
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* Check if it is an extended dir. */
+		if (get_unaligned_le16(&dir->inode_type) == SQFS_LDIR_TYPE)
+			ldir = (struct squashfs_ldir_inode *)table;
+
+		/* Get dir. offset into the directory table */
+		offset = sqfs_dir_offset(table, m_list, m_count);
+		dirs->table = &dirs->dir_table[offset];
+
+		/* Copy directory header */
+		memcpy(dirs->dir_header, &dirs->dir_table[offset],
+		       SQFS_DIR_HEADER_SIZE);
+
+		/* Check for empty directory */
+		if (sqfs_is_empty_dir(table)) {
+			printf("Empty directory.\n");
+			free(dirs->entry);
+			dirs->entry = NULL;
+			ret = SQFS_EMPTY_DIR;
+			goto out;
+		}
+
+		dirs->table += SQFS_DIR_HEADER_SIZE;
+		dirs->size = get_unaligned_le16(&dir->file_size);
+		dirs->entry_count = dirs->dir_header->count + 1;
+		dirs->size -= SQFS_DIR_HEADER_SIZE;
+		free(dirs->entry);
+		dirs->entry = NULL;
+	}
+
+	offset = sqfs_dir_offset(table, m_list, m_count);
+	dirs->table = &dirs->dir_table[offset];
+
+	if (get_unaligned_le16(&dir->inode_type) == SQFS_DIR_TYPE)
+		memcpy(&dirs->i_dir, dir, sizeof(*dir));
+	else
+		memcpy(&dirs->i_ldir, ldir, sizeof(*ldir));
+
+out:
+	free(res);
+	free(rem);
+	free(path);
+	free(target);
+	free(sym_tokens);
+	return ret;
+}
+
+/*
+ * Inode and directory tables are stored as a series of metadata blocks, and
+ * given the compressed size of this table, we can calculate how much metadata
+ * blocks are needed to store the result of the decompression, since a
+ * decompressed metadata block should have a size of 8KiB.
+ */
+static int sqfs_count_metablks(void *table, u32 offset, int table_size)
+{
+	int count = 0, cur_size = 0, ret;
+	u32 data_size;
+	bool comp;
+
+	do {
+		ret = sqfs_read_metablock(table, offset + cur_size, &comp,
+					  &data_size);
+		if (ret)
+			return -EINVAL;
+		cur_size += data_size + SQFS_HEADER_SIZE;
+		count++;
+	} while (cur_size < table_size);
+
+	return count;
+}
+
+/*
+ * Storing the metadata blocks header's positions will be useful while looking
+ * for an entry in the directory table, using the reference (index and offset)
+ * given by its inode.
+ */
+static int sqfs_get_metablk_pos(u32 *pos_list, void *table, u32 offset,
+				int metablks_count)
+{
+	u32 data_size, cur_size = 0;
+	int j, ret = 0;
+	bool comp;
+
+	if (!metablks_count)
+		return -EINVAL;
+
+	for (j = 0; j < metablks_count; j++) {
+		ret = sqfs_read_metablock(table, offset + cur_size, &comp,
+					  &data_size);
+		if (ret)
+			return -EINVAL;
+
+		cur_size += data_size + SQFS_HEADER_SIZE;
+		pos_list[j] = cur_size;
+	}
+
+	return ret;
+}
+
+static int sqfs_read_inode_table(unsigned char **inode_table)
+{
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	u64 start, n_blks, table_offset, table_size;
+	int j, ret = 0, metablks_count;
+	unsigned char *src_table, *itb;
+	u32 src_len, dest_offset = 0;
+	unsigned long dest_len = 0;
+	bool compressed;
+
+	table_size = get_unaligned_le64(&sblk->directory_table_start) -
+		get_unaligned_le64(&sblk->inode_table_start);
+	start = get_unaligned_le64(&sblk->inode_table_start) /
+		ctxt.cur_dev->blksz;
+	n_blks = sqfs_calc_n_blks(sblk->inode_table_start,
+				  sblk->directory_table_start, &table_offset);
+
+	/* Allocate a proper sized buffer (itb) to store the inode table */
+	itb = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+	if (!itb)
+		return -ENOMEM;
+
+	if (sqfs_disk_read(start, n_blks, itb) < 0) {
+		ret = -EINVAL;
+		goto free_itb;
+	}
+
+	/* Parse inode table (metadata block) header */
+	ret = sqfs_read_metablock(itb, table_offset, &compressed, &src_len);
+	if (ret) {
+		ret = -EINVAL;
+		goto free_itb;
+	}
+
+	/* Calculate size to store the whole decompressed table */
+	metablks_count = sqfs_count_metablks(itb, table_offset, table_size);
+	if (metablks_count < 1) {
+		ret = -EINVAL;
+		goto free_itb;
+	}
+
+	*inode_table = malloc(metablks_count * SQFS_METADATA_BLOCK_SIZE);
+	if (!*inode_table) {
+		ret = -ENOMEM;
+		goto free_itb;
+	}
+
+	src_table = itb + table_offset + SQFS_HEADER_SIZE;
+
+	/* Extract compressed Inode table */
+	for (j = 0; j < metablks_count; j++) {
+		sqfs_read_metablock(itb, table_offset, &compressed, &src_len);
+		if (compressed) {
+			dest_len = SQFS_METADATA_BLOCK_SIZE;
+			ret = sqfs_decompress(&ctxt, *inode_table +
+					      dest_offset, &dest_len,
+					      src_table, src_len);
+			if (ret) {
+				free(*inode_table);
+				*inode_table = NULL;
+				goto free_itb;
+			}
+
+			dest_offset += dest_len;
+		} else {
+			memcpy(*inode_table + (j * SQFS_METADATA_BLOCK_SIZE),
+			       src_table, src_len);
+		}
+
+		/*
+		 * Offsets to the decompression destination, to the metadata
+		 * buffer 'itb' and to the decompression source, respectively.
+		 */
+
+		table_offset += src_len + SQFS_HEADER_SIZE;
+		src_table += src_len + SQFS_HEADER_SIZE;
+	}
+
+free_itb:
+	free(itb);
+
+	return ret;
+}
+
+static int sqfs_read_directory_table(unsigned char **dir_table, u32 **pos_list)
+{
+	u64 start, n_blks, table_offset, table_size;
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	int j, ret = 0, metablks_count = -1;
+	unsigned char *src_table, *dtb;
+	u32 src_len, dest_offset = 0;
+	unsigned long dest_len = 0;
+	bool compressed;
+
+	*dir_table = NULL;
+	*pos_list = NULL;
+	/* DIRECTORY TABLE */
+	table_size = get_unaligned_le64(&sblk->fragment_table_start) -
+		get_unaligned_le64(&sblk->directory_table_start);
+	start = get_unaligned_le64(&sblk->directory_table_start) /
+		ctxt.cur_dev->blksz;
+	n_blks = sqfs_calc_n_blks(sblk->directory_table_start,
+				  sblk->fragment_table_start, &table_offset);
+
+	/* Allocate a proper sized buffer (dtb) to store the directory table */
+	dtb = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+	if (!dtb)
+		return -ENOMEM;
+
+	if (sqfs_disk_read(start, n_blks, dtb) < 0)
+		goto out;
+
+	/* Parse directory table (metadata block) header */
+	ret = sqfs_read_metablock(dtb, table_offset, &compressed, &src_len);
+	if (ret)
+		goto out;
+
+	/* Calculate total size to store the whole decompressed table */
+	metablks_count = sqfs_count_metablks(dtb, table_offset, table_size);
+	if (metablks_count < 1)
+		goto out;
+
+	*dir_table = malloc(metablks_count * SQFS_METADATA_BLOCK_SIZE);
+	if (!*dir_table)
+		goto out;
+
+	*pos_list = malloc(metablks_count * sizeof(u32));
+	if (!*pos_list)
+		goto out;
+
+	ret = sqfs_get_metablk_pos(*pos_list, dtb, table_offset,
+				   metablks_count);
+	if (ret) {
+		metablks_count = -1;
+		goto out;
+	}
+
+	src_table = dtb + table_offset + SQFS_HEADER_SIZE;
+
+	/* Extract compressed Directory table */
+	dest_offset = 0;
+	for (j = 0; j < metablks_count; j++) {
+		sqfs_read_metablock(dtb, table_offset, &compressed, &src_len);
+		if (compressed) {
+			dest_len = SQFS_METADATA_BLOCK_SIZE;
+			ret = sqfs_decompress(&ctxt, *dir_table +
+					      (j * SQFS_METADATA_BLOCK_SIZE),
+					      &dest_len, src_table, src_len);
+			if (ret) {
+				metablks_count = -1;
+				goto out;
+			}
+
+			if (dest_len < SQFS_METADATA_BLOCK_SIZE) {
+				dest_offset += dest_len;
+				break;
+			}
+
+			dest_offset += dest_len;
+		} else {
+			memcpy(*dir_table + (j * SQFS_METADATA_BLOCK_SIZE),
+			       src_table, src_len);
+		}
+
+		/*
+		 * Offsets to the decompression destination, to the metadata
+		 * buffer 'dtb' and to the decompression source, respectively.
+		 */
+		table_offset += src_len + SQFS_HEADER_SIZE;
+		src_table += src_len + SQFS_HEADER_SIZE;
+	}
+
+out:
+	if (metablks_count < 1) {
+		free(*dir_table);
+		free(*pos_list);
+		*dir_table = NULL;
+		*pos_list = NULL;
+	}
+	free(dtb);
+
+	return metablks_count;
+}
+
+int sqfs_opendir(const char *filename, struct fs_dir_stream **dirsp)
+{
+	unsigned char *inode_table = NULL, *dir_table = NULL;
+	int j, token_count = 0, ret = 0, metablks_count;
+	struct squashfs_dir_stream *dirs;
+	char **token_list = NULL, *path = NULL;
+	u32 *pos_list = NULL;
+
+	dirs = calloc(1, sizeof(*dirs));
+	if (!dirs)
+		return -EINVAL;
+
+	/* these should be set to NULL to prevent dangling pointers */
+	dirs->dir_header = NULL;
+	dirs->entry = NULL;
+	dirs->table = NULL;
+	dirs->inode_table = NULL;
+	dirs->dir_table = NULL;
+
+	ret = sqfs_read_inode_table(&inode_table);
+	if (ret) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	metablks_count = sqfs_read_directory_table(&dir_table, &pos_list);
+	if (metablks_count < 1) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Tokenize filename */
+	token_count = sqfs_count_tokens(filename);
+	if (token_count < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	path = strdup(filename);
+	if (!path) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	token_list = malloc(token_count * sizeof(char *));
+	if (!token_list) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Fill tokens list */
+	ret = sqfs_tokenize(token_list, token_count, path);
+	if (ret)
+		goto out;
+	/*
+	 * ldir's (extended directory) size is greater than dir, so it works as
+	 * a general solution for the malloc size, since 'i' is a union.
+	 */
+	dirs->inode_table = inode_table;
+	dirs->dir_table = dir_table;
+	ret = sqfs_search_dir(dirs, token_list, token_count, pos_list,
+			      metablks_count);
+	if (ret)
+		goto out;
+
+	if (le16_to_cpu(dirs->i_dir.inode_type) == SQFS_DIR_TYPE)
+		dirs->size = le16_to_cpu(dirs->i_dir.file_size);
+	else
+		dirs->size = le32_to_cpu(dirs->i_ldir.file_size);
+
+	/* Setup directory header */
+	memcpy(dirs->dir_header, dirs->table, SQFS_DIR_HEADER_SIZE);
+	dirs->entry_count = dirs->dir_header->count + 1;
+	dirs->size -= SQFS_DIR_HEADER_SIZE;
+
+	/* Setup entry */
+	dirs->entry = NULL;
+	dirs->table += SQFS_DIR_HEADER_SIZE;
+
+	*dirsp = (struct fs_dir_stream *)dirs;
+
+out:
+	for (j = 0; j < token_count; j++)
+		free(token_list[j]);
+	free(token_list);
+	free(pos_list);
+	free(path);
+	if (ret) {
+		free(inode_table);
+		free(dirs);
+	}
+
+	return ret;
+}
+
+int sqfs_readdir(struct fs_dir_stream *fs_dirs, struct fs_dirent **dentp)
+{
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	struct squashfs_dir_stream *dirs;
+	struct squashfs_lreg_inode *lreg;
+	struct squashfs_base_inode *base;
+	struct squashfs_reg_inode *reg;
+	int i_number, offset = 0, ret;
+	struct fs_dirent *dent;
+	unsigned char *ipos;
+
+	dirs = (struct squashfs_dir_stream *)fs_dirs;
+	if (!dirs->size) {
+		*dentp = NULL;
+		return -SQFS_STOP_READDIR;
+	}
+
+	dent = &dirs->dentp;
+
+	if (!dirs->entry_count) {
+		if (dirs->size > SQFS_DIR_HEADER_SIZE) {
+			dirs->size -= SQFS_DIR_HEADER_SIZE;
+		} else {
+			*dentp = NULL;
+			dirs->size = 0;
+			return -SQFS_STOP_READDIR;
+		}
+
+		if (dirs->size > SQFS_EMPTY_FILE_SIZE) {
+			/* Read follow-up (emitted) dir. header */
+			memcpy(dirs->dir_header, dirs->table,
+			       SQFS_DIR_HEADER_SIZE);
+			dirs->entry_count = dirs->dir_header->count + 1;
+			ret = sqfs_read_entry(&dirs->entry, dirs->table +
+					      SQFS_DIR_HEADER_SIZE);
+			if (ret)
+				return -SQFS_STOP_READDIR;
+
+			dirs->table += SQFS_DIR_HEADER_SIZE;
+		}
+	} else {
+		ret = sqfs_read_entry(&dirs->entry, dirs->table);
+		if (ret)
+			return -SQFS_STOP_READDIR;
+	}
+
+	i_number = dirs->dir_header->inode_number + dirs->entry->inode_offset;
+	ipos = sqfs_find_inode(dirs->inode_table, i_number, sblk->inodes,
+			       sblk->block_size);
+
+	base = (struct squashfs_base_inode *)ipos;
+
+	/* Set entry type and size */
+	switch (dirs->entry->type) {
+	case SQFS_DIR_TYPE:
+	case SQFS_LDIR_TYPE:
+		dent->type = FS_DT_DIR;
+		break;
+	case SQFS_REG_TYPE:
+	case SQFS_LREG_TYPE:
+		/*
+		 * Entries do not differentiate extended from regular types, so
+		 * it needs to be verified manually.
+		 */
+		if (get_unaligned_le16(&base->inode_type) == SQFS_LREG_TYPE) {
+			lreg = (struct squashfs_lreg_inode *)ipos;
+			dent->size = get_unaligned_le64(&lreg->file_size);
+		} else {
+			reg = (struct squashfs_reg_inode *)ipos;
+			dent->size = get_unaligned_le32(&reg->file_size);
+		}
+
+		dent->type = FS_DT_REG;
+		break;
+	case SQFS_BLKDEV_TYPE:
+	case SQFS_CHRDEV_TYPE:
+	case SQFS_LBLKDEV_TYPE:
+	case SQFS_LCHRDEV_TYPE:
+	case SQFS_FIFO_TYPE:
+	case SQFS_SOCKET_TYPE:
+	case SQFS_LFIFO_TYPE:
+	case SQFS_LSOCKET_TYPE:
+		dent->type = SQFS_MISC_ENTRY_TYPE;
+		break;
+	case SQFS_SYMLINK_TYPE:
+	case SQFS_LSYMLINK_TYPE:
+		dent->type = FS_DT_LNK;
+		break;
+	default:
+		return -SQFS_STOP_READDIR;
+	}
+
+	/* Set entry name */
+	strncpy(dent->name, dirs->entry->name, dirs->entry->name_size + 1);
+	dent->name[dirs->entry->name_size + 1] = '\0';
+
+	offset = dirs->entry->name_size + 1 + SQFS_ENTRY_BASE_LENGTH;
+	dirs->entry_count--;
+
+	/* Decrement size to be read */
+	if (dirs->size > offset)
+		dirs->size -= offset;
+	else
+		dirs->size = 0;
+
+	/* Keep a reference to the current entry before incrementing it */
+	dirs->table += offset;
+
+	*dentp = dent;
+
+	return 0;
+}
+
+int sqfs_probe(struct blk_desc *fs_dev_desc, struct disk_partition *fs_partition)
+{
+	struct squashfs_super_block *sblk;
+	int ret;
+
+	ctxt.cur_dev = fs_dev_desc;
+	ctxt.cur_part_info = *fs_partition;
+
+	ret = sqfs_read_sblk(&sblk);
+	if (ret)
+		goto error;
+
+	/* Make sure it has a valid SquashFS magic number*/
+	if (get_unaligned_le32(&sblk->s_magic) != SQFS_MAGIC_NUMBER) {
+		printf("Bad magic number for SquashFS image.\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	ctxt.sblk = sblk;
+
+	ret = sqfs_decompressor_init(&ctxt);
+	if (ret) {
+		goto error;
+	}
+
+	return 0;
+error:
+	ctxt.cur_dev = NULL;
+	free(ctxt.sblk);
+	ctxt.sblk = NULL;
+	return ret;
+}
+
+static char *sqfs_basename(char *path)
+{
+	char *fname;
+
+	fname = path + strlen(path) - 1;
+	while (fname >= path) {
+		if (*fname == '/') {
+			fname++;
+			break;
+		}
+
+		fname--;
+	}
+
+	return fname;
+}
+
+static char *sqfs_dirname(char *path)
+{
+	char *fname;
+
+	fname = sqfs_basename(path);
+	--fname;
+	*fname = '\0';
+
+	return path;
+}
+
+/*
+ * Takes a path to file and splits it in two parts: the filename itself and the
+ * directory's path, e.g.:
+ * path: /path/to/file.txt
+ * file: file.txt
+ * dir: /path/to
+ */
+static int sqfs_split_path(char **file, char **dir, const char *path)
+{
+	char *dirc, *basec, *bname, *dname, *tmp_path;
+	int ret = 0;
+
+	*file = NULL;
+	*dir = NULL;
+	dirc = NULL;
+	basec = NULL;
+	bname = NULL;
+	dname = NULL;
+	tmp_path = NULL;
+
+	/* check for first slash in path*/
+	if (path[0] == '/') {
+		tmp_path = strdup(path);
+		if (!tmp_path) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	} else {
+		tmp_path = malloc(strlen(path) + 2);
+		if (!tmp_path) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		tmp_path[0] = '/';
+		strcpy(tmp_path + 1, path);
+	}
+
+	/* String duplicates */
+	dirc = strdup(tmp_path);
+	if (!dirc) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	basec = strdup(tmp_path);
+	if (!basec) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	dname = sqfs_dirname(dirc);
+	bname = sqfs_basename(basec);
+
+	*file = strdup(bname);
+
+	if (!*file) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (*dname == '\0') {
+		*dir = malloc(2);
+		if (!*dir) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		(*dir)[0] = '/';
+		(*dir)[1] = '\0';
+	} else {
+		*dir = strdup(dname);
+		if (!*dir) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+out:
+	if (ret) {
+		free(*file);
+		free(*dir);
+		*dir = NULL;
+		*file = NULL;
+	}
+	free(basec);
+	free(dirc);
+	free(tmp_path);
+
+	return ret;
+}
+
+static int sqfs_get_regfile_info(struct squashfs_reg_inode *reg,
+				 struct squashfs_file_info *finfo,
+				 struct squashfs_fragment_block_entry *fentry,
+				 __le32 blksz)
+{
+	int datablk_count = 0, ret;
+
+	finfo->size = get_unaligned_le32(&reg->file_size);
+	finfo->offset = get_unaligned_le32(&reg->offset);
+	finfo->start = get_unaligned_le32(&reg->start_block);
+	finfo->frag = SQFS_IS_FRAGMENTED(get_unaligned_le32(&reg->fragment));
+
+	if (finfo->frag && finfo->offset == 0xFFFFFFFF)
+		return -EINVAL;
+
+	if (finfo->size < 1 || finfo->start == 0xFFFFFFFF)
+		return -EINVAL;
+
+	if (finfo->frag) {
+		datablk_count = finfo->size / le32_to_cpu(blksz);
+		ret = sqfs_frag_lookup(get_unaligned_le32(&reg->fragment),
+				       fentry);
+		if (ret < 0)
+			return -EINVAL;
+		finfo->comp = ret;
+		if (fentry->size < 1 || fentry->start == 0x7FFFFFFF)
+			return -EINVAL;
+	} else {
+		datablk_count = DIV_ROUND_UP(finfo->size, le32_to_cpu(blksz));
+	}
+
+	finfo->blk_sizes = malloc(datablk_count * sizeof(u32));
+	if (!finfo->blk_sizes)
+		return -ENOMEM;
+
+	return datablk_count;
+}
+
+static int sqfs_get_lregfile_info(struct squashfs_lreg_inode *lreg,
+				  struct squashfs_file_info *finfo,
+				  struct squashfs_fragment_block_entry *fentry,
+				 __le32 blksz)
+{
+	int datablk_count = 0, ret;
+
+	finfo->size = get_unaligned_le64(&lreg->file_size);
+	finfo->offset = get_unaligned_le32(&lreg->offset);
+	finfo->start = get_unaligned_le64(&lreg->start_block);
+	finfo->frag = SQFS_IS_FRAGMENTED(get_unaligned_le32(&lreg->fragment));
+
+	if (finfo->frag && finfo->offset == 0xFFFFFFFF)
+		return -EINVAL;
+
+	if (finfo->size < 1 || finfo->start == 0x7FFFFFFF)
+		return -EINVAL;
+
+	if (finfo->frag) {
+		datablk_count = finfo->size / le32_to_cpu(blksz);
+		ret = sqfs_frag_lookup(get_unaligned_le32(&lreg->fragment),
+				       fentry);
+		if (ret < 0)
+			return -EINVAL;
+		finfo->comp = ret;
+		if (fentry->size < 1 || fentry->start == 0x7FFFFFFF)
+			return -EINVAL;
+	} else {
+		datablk_count = DIV_ROUND_UP(finfo->size, le32_to_cpu(blksz));
+	}
+
+	finfo->blk_sizes = malloc(datablk_count * sizeof(u32));
+	if (!finfo->blk_sizes)
+		return -ENOMEM;
+
+	return datablk_count;
+}
+
+int sqfs_read(const char *filename, void *buf, loff_t offset, loff_t len,
+	      loff_t *actread)
+{
+	char *dir = NULL, *fragment_block, *datablock = NULL, *data_buffer = NULL;
+	char *fragment = NULL, *file = NULL, *resolved, *data;
+	u64 start, n_blks, table_size, data_offset, table_offset, sparse_size;
+	int ret, j, i_number, datablk_count = 0;
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	struct squashfs_fragment_block_entry frag_entry;
+	struct squashfs_file_info finfo = {0};
+	struct squashfs_symlink_inode *symlink;
+	struct fs_dir_stream *dirsp = NULL;
+	struct squashfs_dir_stream *dirs;
+	struct squashfs_lreg_inode *lreg;
+	struct squashfs_base_inode *base;
+	struct squashfs_reg_inode *reg;
+	unsigned long dest_len;
+	struct fs_dirent *dent;
+	unsigned char *ipos;
+
+	*actread = 0;
+
+	if (offset) {
+		/*
+		 * TODO: implement reading at an offset in file
+		 */
+		printf("Error: reading at a specific offset in a squashfs file is not supported yet.\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * sqfs_opendir will uncompress inode and directory tables, and will
+	 * return a pointer to the directory that contains the requested file.
+	 */
+	sqfs_split_path(&file, &dir, filename);
+	ret = sqfs_opendir(dir, &dirsp);
+	if (ret) {
+		goto out;
+	}
+
+	dirs = (struct squashfs_dir_stream *)dirsp;
+
+	/* For now, only regular files are able to be loaded */
+	while (!sqfs_readdir(dirsp, &dent)) {
+		ret = strcmp(dent->name, file);
+		if (!ret)
+			break;
+
+		free(dirs->entry);
+		dirs->entry = NULL;
+	}
+
+	if (ret) {
+		printf("File not found.\n");
+		*actread = 0;
+		ret = -ENOENT;
+		goto out;
+	}
+
+	i_number = dirs->dir_header->inode_number + dirs->entry->inode_offset;
+	ipos = sqfs_find_inode(dirs->inode_table, i_number, sblk->inodes,
+			       sblk->block_size);
+
+	base = (struct squashfs_base_inode *)ipos;
+	switch (get_unaligned_le16(&base->inode_type)) {
+	case SQFS_REG_TYPE:
+		reg = (struct squashfs_reg_inode *)ipos;
+		datablk_count = sqfs_get_regfile_info(reg, &finfo, &frag_entry,
+						      sblk->block_size);
+		if (datablk_count < 0) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		memcpy(finfo.blk_sizes, ipos + sizeof(*reg),
+		       datablk_count * sizeof(u32));
+		break;
+	case SQFS_LREG_TYPE:
+		lreg = (struct squashfs_lreg_inode *)ipos;
+		datablk_count = sqfs_get_lregfile_info(lreg, &finfo,
+						       &frag_entry,
+						       sblk->block_size);
+		if (datablk_count < 0) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		memcpy(finfo.blk_sizes, ipos + sizeof(*lreg),
+		       datablk_count * sizeof(u32));
+		break;
+	case SQFS_SYMLINK_TYPE:
+	case SQFS_LSYMLINK_TYPE:
+		symlink = (struct squashfs_symlink_inode *)ipos;
+		resolved = sqfs_resolve_symlink(symlink, filename);
+		ret = sqfs_read(resolved, buf, offset, len, actread);
+		free(resolved);
+		goto out;
+	case SQFS_BLKDEV_TYPE:
+	case SQFS_CHRDEV_TYPE:
+	case SQFS_LBLKDEV_TYPE:
+	case SQFS_LCHRDEV_TYPE:
+	case SQFS_FIFO_TYPE:
+	case SQFS_SOCKET_TYPE:
+	case SQFS_LFIFO_TYPE:
+	case SQFS_LSOCKET_TYPE:
+	default:
+		printf("Unsupported entry type\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* If the user specifies a length, check its sanity */
+	if (len) {
+		if (len > finfo.size) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		finfo.size = len;
+	} else {
+		len = finfo.size;
+	}
+
+	if (datablk_count) {
+		data_offset = finfo.start;
+		datablock = malloc(get_unaligned_le32(&sblk->block_size));
+		if (!datablock) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+	for (j = 0; j < datablk_count; j++) {
+		start = data_offset / ctxt.cur_dev->blksz;
+		table_size = SQFS_BLOCK_SIZE(finfo.blk_sizes[j]);
+		table_offset = data_offset - (start * ctxt.cur_dev->blksz);
+		n_blks = DIV_ROUND_UP(table_size + table_offset,
+				      ctxt.cur_dev->blksz);
+
+		/* Don't load any data for sparse blocks */
+		if (finfo.blk_sizes[j] == 0) {
+			n_blks = 0;
+			table_offset = 0;
+			data_buffer = NULL;
+			data = NULL;
+		} else {
+			data_buffer = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+
+			if (!data_buffer) {
+				ret = -ENOMEM;
+				goto out;
+			}
+
+			ret = sqfs_disk_read(start, n_blks, data_buffer);
+			if (ret < 0) {
+				/*
+				 * Possible causes: too many data blocks or too large
+				 * SquashFS block size. Tip: re-compile the SquashFS
+				 * image with mksquashfs's -b <block_size> option.
+				 */
+				printf("Error: too many data blocks to be read.\n");
+				goto out;
+			}
+
+			data = data_buffer + table_offset;
+		}
+
+		/* Load the data */
+		if (finfo.blk_sizes[j] == 0) {
+			/* This is a sparse block */
+			sparse_size = get_unaligned_le32(&sblk->block_size);
+			if ((*actread + sparse_size) > len)
+				sparse_size = len - *actread;
+			memset(buf + *actread, 0, sparse_size);
+			*actread += sparse_size;
+		} else if (SQFS_COMPRESSED_BLOCK(finfo.blk_sizes[j])) {
+			dest_len = get_unaligned_le32(&sblk->block_size);
+			ret = sqfs_decompress(&ctxt, datablock, &dest_len,
+					      data, table_size);
+			if (ret)
+				goto out;
+
+			if ((*actread + dest_len) > len)
+				dest_len = len - *actread;
+			memcpy(buf + *actread, datablock, dest_len);
+			*actread += dest_len;
+		} else {
+			if ((*actread + table_size) > len)
+				table_size = len - *actread;
+			memcpy(buf + *actread, data, table_size);
+			*actread += table_size;
+		}
+
+		data_offset += table_size;
+		if (data_buffer)
+			free(data_buffer);
+		data_buffer = NULL;
+		if (*actread >= len)
+			break;
+	}
+
+	/*
+	 * There is no need to continue if the file is not fragmented.
+	 */
+	if (!finfo.frag) {
+		ret = 0;
+		goto out;
+	}
+
+	start = frag_entry.start / ctxt.cur_dev->blksz;
+	table_size = SQFS_BLOCK_SIZE(frag_entry.size);
+	table_offset = frag_entry.start - (start * ctxt.cur_dev->blksz);
+	n_blks = DIV_ROUND_UP(table_size + table_offset, ctxt.cur_dev->blksz);
+
+	fragment = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+
+	if (!fragment) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = sqfs_disk_read(start, n_blks, fragment);
+	if (ret < 0)
+		goto out;
+
+	/* File compressed and fragmented */
+	if (finfo.frag && finfo.comp) {
+		dest_len = get_unaligned_le32(&sblk->block_size);
+		fragment_block = malloc(dest_len);
+		if (!fragment_block) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		ret = sqfs_decompress(&ctxt, fragment_block, &dest_len,
+				      (void *)fragment  + table_offset,
+				      frag_entry.size);
+		if (ret) {
+			free(fragment_block);
+			goto out;
+		}
+
+		memcpy(buf + *actread, &fragment_block[finfo.offset], finfo.size - *actread);
+		*actread = finfo.size;
+
+		free(fragment_block);
+
+	} else if (finfo.frag && !finfo.comp) {
+		fragment_block = (void *)fragment + table_offset;
+
+		memcpy(buf + *actread, &fragment_block[finfo.offset], finfo.size - *actread);
+		*actread = finfo.size;
+	}
+
+out:
+	free(fragment);
+	if (datablk_count) {
+		free(data_buffer);
+		free(datablock);
+	}
+	free(file);
+	free(dir);
+	free(finfo.blk_sizes);
+	sqfs_closedir(dirsp);
+
+	return ret;
+}
+
+int sqfs_size(const char *filename, loff_t *size)
+{
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	struct squashfs_symlink_inode *symlink;
+	struct fs_dir_stream *dirsp = NULL;
+	struct squashfs_base_inode *base;
+	struct squashfs_dir_stream *dirs;
+	struct squashfs_lreg_inode *lreg;
+	struct squashfs_reg_inode *reg;
+	char *dir, *file, *resolved;
+	struct fs_dirent *dent;
+	unsigned char *ipos;
+	int ret, i_number;
+
+	sqfs_split_path(&file, &dir, filename);
+	/*
+	 * sqfs_opendir will uncompress inode and directory tables, and will
+	 * return a pointer to the directory that contains the requested file.
+	 */
+	ret = sqfs_opendir(dir, &dirsp);
+	if (ret) {
+		ret = -EINVAL;
+		goto free_strings;
+	}
+
+	dirs = (struct squashfs_dir_stream *)dirsp;
+
+	while (!sqfs_readdir(dirsp, &dent)) {
+		ret = strcmp(dent->name, file);
+		if (!ret)
+			break;
+		free(dirs->entry);
+		dirs->entry = NULL;
+	}
+
+	if (ret) {
+		printf("File not found.\n");
+		*size = 0;
+		ret = -EINVAL;
+		goto free_strings;
+	}
+
+	i_number = dirs->dir_header->inode_number + dirs->entry->inode_offset;
+	ipos = sqfs_find_inode(dirs->inode_table, i_number, sblk->inodes,
+			       sblk->block_size);
+	free(dirs->entry);
+	dirs->entry = NULL;
+
+	base = (struct squashfs_base_inode *)ipos;
+	switch (get_unaligned_le16(&base->inode_type)) {
+	case SQFS_REG_TYPE:
+		reg = (struct squashfs_reg_inode *)ipos;
+		*size = get_unaligned_le32(&reg->file_size);
+		break;
+	case SQFS_LREG_TYPE:
+		lreg = (struct squashfs_lreg_inode *)ipos;
+		*size = get_unaligned_le64(&lreg->file_size);
+		break;
+	case SQFS_SYMLINK_TYPE:
+	case SQFS_LSYMLINK_TYPE:
+		symlink = (struct squashfs_symlink_inode *)ipos;
+		resolved = sqfs_resolve_symlink(symlink, filename);
+		ret = sqfs_size(resolved, size);
+		free(resolved);
+		break;
+	case SQFS_BLKDEV_TYPE:
+	case SQFS_CHRDEV_TYPE:
+	case SQFS_LBLKDEV_TYPE:
+	case SQFS_LCHRDEV_TYPE:
+	case SQFS_FIFO_TYPE:
+	case SQFS_SOCKET_TYPE:
+	case SQFS_LFIFO_TYPE:
+	case SQFS_LSOCKET_TYPE:
+	default:
+		printf("Unable to recover entry's size.\n");
+		*size = 0;
+		ret = -EINVAL;
+		break;
+	}
+
+free_strings:
+	free(dir);
+	free(file);
+
+	sqfs_closedir(dirsp);
+
+	return ret;
+}
+
+int sqfs_exists(const char *filename)
+{
+	struct fs_dir_stream *dirsp = NULL;
+	struct squashfs_dir_stream *dirs;
+	char *dir, *file;
+	struct fs_dirent *dent;
+	int ret;
+
+	sqfs_split_path(&file, &dir, filename);
+	/*
+	 * sqfs_opendir will uncompress inode and directory tables, and will
+	 * return a pointer to the directory that contains the requested file.
+	 */
+	ret = sqfs_opendir(dir, &dirsp);
+	if (ret) {
+		ret = -EINVAL;
+		goto free_strings;
+	}
+
+	dirs = (struct squashfs_dir_stream *)dirsp;
+
+	while (!sqfs_readdir(dirsp, &dent)) {
+		ret = strcmp(dent->name, file);
+		if (!ret)
+			break;
+		free(dirs->entry);
+		dirs->entry = NULL;
+	}
+
+	sqfs_closedir(dirsp);
+
+free_strings:
+	free(dir);
+	free(file);
+
+	return ret == 0;
+}
+
+void sqfs_close(void)
+{
+	sqfs_decompressor_cleanup(&ctxt);
+	free(ctxt.sblk);
+	ctxt.sblk = NULL;
+	ctxt.cur_dev = NULL;
+}
+
+void sqfs_closedir(struct fs_dir_stream *dirs)
+{
+	struct squashfs_dir_stream *sqfs_dirs;
+
+	if (!dirs)
+		return;
+
+	sqfs_dirs = (struct squashfs_dir_stream *)dirs;
+	free(sqfs_dirs->inode_table);
+	free(sqfs_dirs->dir_table);
+	free(sqfs_dirs->dir_header);
+	free(sqfs_dirs);
+}
diff --git a/fs/squashfs/sqfs_decompressor.c b/fs/squashfs/sqfs_decompressor.c
new file mode 100644
index 0000000000..b4b4feb859
--- /dev/null
+++ b/fs/squashfs/sqfs_decompressor.c
@@ -0,0 +1,155 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#if IS_ENABLED(CONFIG_LZO)
+#include <linux/lzo.h>
+#endif
+
+#if IS_ENABLED(CONFIG_ZLIB)
+#include <u-boot/zlib.h>
+#endif
+
+#if IS_ENABLED(CONFIG_ZSTD)
+#include <linux/zstd.h>
+#endif
+
+#include "sqfs_decompressor.h"
+#include "sqfs_utils.h"
+
+int sqfs_decompressor_init(struct squashfs_ctxt *ctxt)
+{
+	u16 comp_type = get_unaligned_le16(&ctxt->sblk->compression);
+
+	switch (comp_type) {
+#if IS_ENABLED(CONFIG_LZO)
+	case SQFS_COMP_LZO:
+		break;
+#endif
+#if IS_ENABLED(CONFIG_ZLIB)
+	case SQFS_COMP_ZLIB:
+		break;
+#endif
+#if IS_ENABLED(CONFIG_ZSTD)
+	case SQFS_COMP_ZSTD:
+		ctxt->zstd_workspace = malloc(ZSTD_DCtxWorkspaceBound());
+		if (!ctxt->zstd_workspace)
+			return -ENOMEM;
+		break;
+#endif
+	default:
+		printf("[sqfs]Error: unknown compression type. comp_type:%d(0x%04x)\n", comp_type, comp_type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void sqfs_decompressor_cleanup(struct squashfs_ctxt *ctxt)
+{
+	u16 comp_type = get_unaligned_le16(&ctxt->sblk->compression);
+
+	switch (comp_type) {
+#if IS_ENABLED(CONFIG_LZO)
+	case SQFS_COMP_LZO:
+		break;
+#endif
+#if IS_ENABLED(CONFIG_ZLIB)
+	case SQFS_COMP_ZLIB:
+		break;
+#endif
+#if IS_ENABLED(CONFIG_ZSTD)
+	case SQFS_COMP_ZSTD:
+		free(ctxt->zstd_workspace);
+		break;
+#endif
+	}
+}
+
+#if IS_ENABLED(CONFIG_ZLIB)
+static void zlib_decompression_status(int ret)
+{
+	switch (ret) {
+	case Z_BUF_ERROR:
+		printf("Error: 'dest' buffer is not large enough.\n");
+		break;
+	case Z_DATA_ERROR:
+		printf("Error: corrupted compressed data.\n");
+		break;
+	case Z_MEM_ERROR:
+		printf("Error: insufficient memory.\n");
+		break;
+	}
+}
+#endif
+
+#if IS_ENABLED(CONFIG_ZSTD)
+static int sqfs_zstd_decompress(struct squashfs_ctxt *ctxt, void *dest,
+				unsigned long dest_len, void *source, u32 src_len)
+{
+	ZSTD_DCtx *ctx;
+	size_t wsize;
+	int ret;
+
+	wsize = ZSTD_DCtxWorkspaceBound();
+	ctx = ZSTD_initDCtx(ctxt->zstd_workspace, wsize);
+	ret = ZSTD_decompressDCtx(ctx, dest, dest_len, source, src_len);
+
+	return ZSTD_isError(ret);
+}
+#endif /* CONFIG_ZSTD */
+
+int sqfs_decompress(struct squashfs_ctxt *ctxt, void *dest,
+		    unsigned long *dest_len, void *source, u32 src_len)
+{
+	u16 comp_type = get_unaligned_le16(&ctxt->sblk->compression);
+	int ret = 0;
+
+	switch (comp_type) {
+#if IS_ENABLED(CONFIG_LZO)
+	case SQFS_COMP_LZO: {
+		size_t lzo_dest_len = *dest_len;
+		ret = lzo1x_decompress_safe(source, src_len, dest, &lzo_dest_len);
+		if (ret) {
+			printf("LZO decompression failed. Error code: %d\n", ret);
+			return -EINVAL;
+		}
+
+		break;
+	}
+#endif
+#if IS_ENABLED(CONFIG_ZLIB)
+	case SQFS_COMP_ZLIB:
+		ret = uncompress(dest, dest_len, source, src_len);
+		if (ret) {
+			zlib_decompression_status(ret);
+			return -EINVAL;
+		}
+
+		break;
+#endif
+#if IS_ENABLED(CONFIG_ZSTD)
+	case SQFS_COMP_ZSTD:
+		ret = sqfs_zstd_decompress(ctxt, dest, *dest_len, source, src_len);
+		if (ret) {
+			printf("ZSTD Error code: %d\n", ZSTD_getErrorCode(ret));
+			return -EINVAL;
+		}
+
+		break;
+#endif
+	default:
+		printf("[sqfs]Error:unknown compression type. comp_type:%d(0x%04x)\n", comp_type, comp_type);
+		return -EINVAL;
+	}
+
+	return ret;
+}
diff --git a/fs/squashfs/sqfs_decompressor.h b/fs/squashfs/sqfs_decompressor.h
new file mode 100644
index 0000000000..892cfb6974
--- /dev/null
+++ b/fs/squashfs/sqfs_decompressor.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#ifndef SQFS_DECOMPRESSOR_H
+#define SQFS_DECOMPRESSOR_H
+
+#include <stdint.h>
+#include "sqfs_filesystem.h"
+
+#define SQFS_COMP_ZLIB 1
+#define SQFS_COMP_LZMA 2
+#define SQFS_COMP_LZO 3
+#define SQFS_COMP_XZ 4
+#define SQFS_COMP_LZ4 5
+#define SQFS_COMP_ZSTD 6
+
+/* LZMA does not support any compression options */
+
+struct squashfs_gzip_opts {
+	u32 compression_level;
+	u16 window_size;
+	u16 strategies;
+};
+
+struct squashfs_xz_opts {
+	u32 dictionary_size;
+	u32 executable_filters;
+};
+
+struct squashfs_lz4_opts {
+	u32 version;
+	u32 flags;
+};
+
+struct squashfs_zstd_opts {
+	u32 compression_level;
+};
+
+struct squashfs_lzo_opts {
+	u32 algorithm;
+	u32 level;
+};
+
+union squashfs_compression_opts {
+	struct squashfs_gzip_opts *gzip;
+	struct squashfs_xz_opts *xz;
+	struct squashfs_lz4_opts *lz4;
+	struct squashfs_zstd_opts *zstd;
+	struct squashfs_lzo_opts *lzo;
+};
+
+int sqfs_decompress(struct squashfs_ctxt *ctxt, void *dest,
+		    unsigned long *dest_len, void *source, u32 src_len);
+int sqfs_decompressor_init(struct squashfs_ctxt *ctxt);
+void sqfs_decompressor_cleanup(struct squashfs_ctxt *ctxt);
+
+#endif /* SQFS_DECOMPRESSOR_H */
diff --git a/fs/squashfs/sqfs_dir.c b/fs/squashfs/sqfs_dir.c
new file mode 100644
index 0000000000..a265b98fe6
--- /dev/null
+++ b/fs/squashfs/sqfs_dir.c
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#include <errno.h>
+#include <linux/types.h>
+#include <linux/byteorder/little_endian.h>
+#include <linux/byteorder/generic.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "sqfs_filesystem.h"
+#include "sqfs_utils.h"
+
+bool sqfs_is_dir(u16 type)
+{
+	return type == SQFS_DIR_TYPE || type == SQFS_LDIR_TYPE;
+}
+
+/*
+ * Receives a pointer (void *) to a position in the inode table containing the
+ * directory's inode. Returns directory inode offset into the directory table.
+ * m_list contains each metadata block's position, and m_count is the number of
+ * elements of m_list. Those metadata blocks come from the compressed directory
+ * table.
+ */
+int sqfs_dir_offset(void *dir_i, u32 *m_list, int m_count)
+{
+	struct squashfs_base_inode *base = dir_i;
+	struct squashfs_ldir_inode *ldir;
+	struct squashfs_dir_inode *dir;
+	u32 start_block;
+	int j, offset;
+
+	switch (get_unaligned_le16(&base->inode_type)) {
+	case SQFS_DIR_TYPE:
+		dir = (struct squashfs_dir_inode *)base;
+		start_block = get_unaligned_le32(&dir->start_block);
+		offset = get_unaligned_le16(&dir->offset);
+		break;
+	case SQFS_LDIR_TYPE:
+		ldir = (struct squashfs_ldir_inode *)base;
+		start_block = get_unaligned_le32(&ldir->start_block);
+		offset = get_unaligned_le16(&ldir->offset);
+		break;
+	default:
+		printf("Error: this is not a directory.\n");
+		return -EINVAL;
+	}
+
+	if (offset < 0)
+		return -EINVAL;
+
+	for (j = 0; j < m_count; j++) {
+		if (m_list[j] == start_block)
+			return (++j * SQFS_METADATA_BLOCK_SIZE) + offset;
+	}
+
+	if (start_block == 0)
+		return offset;
+
+	printf("Error: invalid inode reference to directory table.\n");
+
+	return -EINVAL;
+}
+
+bool sqfs_is_empty_dir(void *dir_i)
+{
+	struct squashfs_base_inode *base = dir_i;
+	struct squashfs_ldir_inode *ldir;
+	struct squashfs_dir_inode *dir;
+	u32 file_size;
+
+	switch (get_unaligned_le16(&base->inode_type)) {
+	case SQFS_DIR_TYPE:
+		dir = (struct squashfs_dir_inode *)base;
+		file_size = get_unaligned_le16(&dir->file_size);
+		break;
+	case SQFS_LDIR_TYPE:
+		ldir = (struct squashfs_ldir_inode *)base;
+		file_size = get_unaligned_le16(&ldir->file_size);
+		break;
+	default:
+		printf("Error: this is not a directory.\n");
+		return false;
+	}
+
+	return file_size == SQFS_EMPTY_FILE_SIZE;
+}
diff --git a/fs/squashfs/sqfs_filesystem.h b/fs/squashfs/sqfs_filesystem.h
new file mode 100644
index 0000000000..856cd15e34
--- /dev/null
+++ b/fs/squashfs/sqfs_filesystem.h
@@ -0,0 +1,310 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#ifndef SQFS_FILESYSTEM_H
+#define SQFS_FILESYSTEM_H
+
+#include <asm/unaligned.h>
+#include <fs.h>
+#include <part.h>
+#include <stdint.h>
+
+#define SQFS_UNCOMPRESSED_DATA 0x0002
+#define SQFS_MAGIC_NUMBER 0x73717368
+/* The three first members of squashfs_dir_index make a total of 12 bytes */
+#define SQFS_DIR_INDEX_BASE_LENGTH 12
+/* size of metadata (inode and directory) blocks */
+#define SQFS_METADATA_BLOCK_SIZE 8192
+/* Max. number of fragment entries in a metadata block is 512 */
+#define SQFS_MAX_ENTRIES 512
+/* Metadata blocks start by a 2-byte length header */
+#define SQFS_HEADER_SIZE 2
+#define SQFS_LREG_INODE_MIN_SIZE 56
+#define SQFS_DIR_HEADER_SIZE 12
+#define SQFS_MISC_ENTRY_TYPE -1
+#define SQFS_EMPTY_FILE_SIZE 3
+#define SQFS_STOP_READDIR 1
+#define SQFS_EMPTY_DIR -1
+/*
+ * A directory entry object has a fixed length of 8 bytes, corresponding to its
+ * first four members, plus the size of the entry name, which is equal to
+ * 'entry_name' + 1 bytes.
+ */
+#define SQFS_ENTRY_BASE_LENGTH 8
+/* Inode types */
+#define SQFS_DIR_TYPE 1
+#define SQFS_REG_TYPE 2
+#define SQFS_SYMLINK_TYPE 3
+#define SQFS_BLKDEV_TYPE 4
+#define SQFS_CHRDEV_TYPE 5
+#define SQFS_FIFO_TYPE 6
+#define SQFS_SOCKET_TYPE 7
+#define SQFS_LDIR_TYPE 8
+#define SQFS_LREG_TYPE 9
+#define SQFS_LSYMLINK_TYPE 10
+#define SQFS_LBLKDEV_TYPE 11
+#define SQFS_LCHRDEV_TYPE 12
+#define SQFS_LFIFO_TYPE 13
+#define SQFS_LSOCKET_TYPE 14
+
+struct squashfs_super_block {
+	__le32 s_magic;
+	__le32 inodes;
+	__le32 mkfs_time;
+	__le32 block_size;
+	__le32 fragments;
+	__le16 compression;
+	__le16 block_log;
+	__le16 flags;
+	__le16 no_ids;
+	__le16 s_major;
+	__le16 s_minor;
+	__le64 root_inode;
+	__le64 bytes_used;
+	__le64 id_table_start;
+	__le64 xattr_id_table_start;
+	__le64 inode_table_start;
+	__le64 directory_table_start;
+	__le64 fragment_table_start;
+	__le64 export_table_start;
+};
+
+struct squashfs_ctxt {
+	struct disk_partition cur_part_info;
+	struct blk_desc *cur_dev;
+	struct squashfs_super_block *sblk;
+#if IS_ENABLED(CONFIG_ZSTD)
+	void *zstd_workspace;
+#endif
+};
+
+struct squashfs_directory_index {
+	u32 index;
+	u32 start;
+	u32 size;
+	char name[0];
+};
+
+struct squashfs_base_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+};
+
+struct squashfs_ipc_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+};
+
+struct squashfs_lipc_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 xattr;
+};
+
+struct squashfs_dev_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 rdev;
+};
+
+struct squashfs_ldev_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 rdev;
+	__le32 xattr;
+};
+
+struct squashfs_symlink_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 symlink_size;
+	char symlink[0];
+};
+
+struct squashfs_reg_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 start_block;
+	__le32 fragment;
+	__le32 offset;
+	__le32 file_size;
+	__le32 block_list[0];
+};
+
+struct squashfs_lreg_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le64 start_block;
+	__le64 file_size;
+	__le64 sparse;
+	__le32 nlink;
+	__le32 fragment;
+	__le32 offset;
+	__le32 xattr;
+	__le32 block_list[0];
+};
+
+struct squashfs_dir_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 start_block;
+	__le32 nlink;
+	__le16 file_size;
+	__le16 offset;
+	__le32 parent_inode;
+};
+
+struct squashfs_ldir_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 file_size;
+	__le32 start_block;
+	__le32 parent_inode;
+	__le16 i_count;
+	__le16 offset;
+	__le32 xattr;
+	struct squashfs_directory_index index[0];
+};
+
+union squashfs_inode {
+	struct squashfs_base_inode *base;
+	struct squashfs_dev_inode *dev;
+	struct squashfs_ldev_inode *ldev;
+	struct squashfs_symlink_inode *symlink;
+	struct squashfs_reg_inode *reg;
+	struct squashfs_lreg_inode *lreg;
+	struct squashfs_dir_inode *dir;
+	struct squashfs_ldir_inode *ldir;
+	struct squashfs_ipc_inode *ipc;
+	struct squashfs_lipc_inode *lipc;
+};
+
+struct squashfs_directory_entry {
+	u16 offset;
+	u16 inode_offset;
+	u16 type;
+	u16 name_size;
+	char name[0];
+};
+
+struct squashfs_directory_header {
+	u32 count;
+	u32 start;
+	u32 inode_number;
+};
+
+struct squashfs_fragment_block_entry {
+	u64 start;
+	u32 size;
+	u32 _unused;
+};
+
+struct squashfs_dir_stream {
+	struct fs_dir_stream fs_dirs;
+	struct fs_dirent dentp;
+	/*
+	 * 'size' is the uncompressed size of the entire listing, including
+	 * headers. 'entry_count' is the number of entries following a
+	 * specific header. Both variables are decremented in sqfs_readdir() so
+	 * the function knows when the end of the directory is reached.
+	 */
+	size_t size;
+	int entry_count;
+	/* SquashFS structures */
+	struct squashfs_directory_header *dir_header;
+	struct squashfs_directory_entry *entry;
+	/*
+	 * 'table' points to a position into the directory table. Both 'table'
+	 * and 'inode' are defined for the first time in sqfs_opendir().
+	 * 'table's value changes in sqfs_readdir().
+	 */
+	unsigned char *table;
+	union squashfs_inode i;
+	struct squashfs_dir_inode i_dir;
+	struct squashfs_ldir_inode i_ldir;
+	/*
+	 * References to the tables' beginnings. They are assigned in
+	 * sqfs_opendir() and freed in sqfs_closedir().
+	 */
+	unsigned char *inode_table;
+	unsigned char *dir_table;
+};
+
+struct squashfs_file_info {
+	/* File size in bytes (uncompressed) */
+	size_t size;
+	/* Reference to list of data blocks's sizes */
+	u32 *blk_sizes;
+	/* Offset into the fragment block */
+	u32 offset;
+	/* Offset in which the data blocks begin */
+	u64 start;
+	/* Is file fragmented? */
+	bool frag;
+	/* Compressed fragment */
+	bool comp;
+};
+
+void *sqfs_find_inode(void *inode_table, int inode_number, __le32 inode_count,
+		      __le32 block_size);
+
+int sqfs_dir_offset(void *dir_i, u32 *m_list, int m_count);
+
+int sqfs_read_metablock(unsigned char *file_mapping, int offset,
+			bool *compressed, u32 *data_size);
+
+bool sqfs_is_empty_dir(void *dir_i);
+
+bool sqfs_is_dir(u16 type);
+
+#endif /* SQFS_FILESYSTEM_H */
diff --git a/fs/squashfs/sqfs_inode.c b/fs/squashfs/sqfs_inode.c
new file mode 100644
index 0000000000..d25cfb53e7
--- /dev/null
+++ b/fs/squashfs/sqfs_inode.c
@@ -0,0 +1,162 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#include <asm/unaligned.h>
+#include <compiler.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "sqfs_decompressor.h"
+#include "sqfs_filesystem.h"
+#include "sqfs_utils.h"
+
+int sqfs_inode_size(struct squashfs_base_inode *inode, u32 blk_size)
+{
+	switch (get_unaligned_le16(&inode->inode_type)) {
+	case SQFS_DIR_TYPE:
+		return sizeof(struct squashfs_dir_inode);
+
+	case SQFS_REG_TYPE: {
+		struct squashfs_reg_inode *reg =
+			(struct squashfs_reg_inode *)inode;
+		u32 fragment = get_unaligned_le32(&reg->fragment);
+		u32 file_size = get_unaligned_le32(&reg->file_size);
+		unsigned int blk_list_size;
+
+		if (SQFS_IS_FRAGMENTED(fragment))
+			blk_list_size = file_size / blk_size;
+		else
+			blk_list_size = DIV_ROUND_UP(file_size, blk_size);
+
+		return sizeof(*reg) + blk_list_size * sizeof(u32);
+	}
+
+	case SQFS_LDIR_TYPE: {
+		struct squashfs_ldir_inode *ldir =
+			(struct squashfs_ldir_inode *)inode;
+		u16 i_count = get_unaligned_le16(&ldir->i_count);
+		unsigned int index_list_size = 0, l = 0;
+		struct squashfs_directory_index *di;
+		u32 sz;
+
+		if (i_count == 0)
+			return sizeof(*ldir);
+
+		di = ldir->index;
+		while (l < i_count) {
+			sz = get_unaligned_le32(&di->size) + 1;
+			index_list_size += sz;
+			di = (void *)di + sizeof(*di) + sz;
+			l++;
+		}
+
+		return sizeof(*ldir) + index_list_size +
+			i_count * SQFS_DIR_INDEX_BASE_LENGTH;
+	}
+
+	case SQFS_LREG_TYPE: {
+		struct squashfs_lreg_inode *lreg =
+			(struct squashfs_lreg_inode *)inode;
+		u32 fragment = get_unaligned_le32(&lreg->fragment);
+		u64 file_size = get_unaligned_le64(&lreg->file_size);
+		unsigned int blk_list_size;
+
+		if (fragment == 0xFFFFFFFF)
+			blk_list_size = DIV_ROUND_UP(file_size, blk_size);
+		else
+			blk_list_size = file_size / blk_size;
+
+		return sizeof(*lreg) + blk_list_size * sizeof(u32);
+	}
+
+	case SQFS_SYMLINK_TYPE:
+	case SQFS_LSYMLINK_TYPE: {
+		struct squashfs_symlink_inode *symlink =
+			(struct squashfs_symlink_inode *)inode;
+
+		return sizeof(*symlink) +
+			get_unaligned_le32(&symlink->symlink_size);
+	}
+
+	case SQFS_BLKDEV_TYPE:
+	case SQFS_CHRDEV_TYPE:
+		return sizeof(struct squashfs_dev_inode);
+	case SQFS_LBLKDEV_TYPE:
+	case SQFS_LCHRDEV_TYPE:
+		return sizeof(struct squashfs_ldev_inode);
+	case SQFS_FIFO_TYPE:
+	case SQFS_SOCKET_TYPE:
+		return sizeof(struct squashfs_ipc_inode);
+	case SQFS_LFIFO_TYPE:
+	case SQFS_LSOCKET_TYPE:
+		return sizeof(struct squashfs_lipc_inode);
+	default:
+		printf("Error while searching inode: unknown type.\n");
+		return -EINVAL;
+	}
+}
+
+/*
+ * Given the uncompressed inode table, the inode to be found and the number of
+ * inodes in the table, return inode position in case of success.
+ */
+void *sqfs_find_inode(void *inode_table, int inode_number, __le32 inode_count,
+		      __le32 block_size)
+{
+	struct squashfs_base_inode *base;
+	unsigned int offset = 0, k;
+	int sz;
+
+	if (!inode_table) {
+		printf("%s: Invalid pointer to inode table.\n", __func__);
+		return NULL;
+	}
+
+	for (k = 0; k < le32_to_cpu(inode_count); k++) {
+		base = inode_table + offset;
+		if (get_unaligned_le32(&base->inode_number) == inode_number)
+			return inode_table + offset;
+
+		sz = sqfs_inode_size(base, le32_to_cpu(block_size));
+		if (sz < 0)
+			return NULL;
+
+		offset += sz;
+	}
+
+	printf("Inode not found.\n");
+
+	return NULL;
+}
+
+int sqfs_read_metablock(unsigned char *file_mapping, int offset,
+			bool *compressed, u32 *data_size)
+{
+	const unsigned char *data;
+	u16 header;
+
+	if (!file_mapping)
+		return -EFAULT;
+	data = file_mapping + offset;
+
+	header = get_unaligned((u16 *)data);
+	if (!header)
+		return -EINVAL;
+
+	*compressed = SQFS_COMPRESSED_METADATA(header);
+	*data_size = SQFS_METADATA_SIZE(header);
+
+	if (*data_size > SQFS_METADATA_BLOCK_SIZE) {
+		printf("Invalid metatada block size: %d bytes.\n", *data_size);
+		return -EINVAL;
+	}
+
+	return 0;
+}
diff --git a/fs/squashfs/sqfs_utils.h b/fs/squashfs/sqfs_utils.h
new file mode 100644
index 0000000000..1260abe22b
--- /dev/null
+++ b/fs/squashfs/sqfs_utils.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#ifndef SQFS_UTILS_H
+#define SQFS_UTILS_H
+
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <stdbool.h>
+
+#define SQFS_FRAGMENT_INDEX_OFFSET(A) ((A) % SQFS_MAX_ENTRIES)
+#define SQFS_FRAGMENT_INDEX(A) ((A) / SQFS_MAX_ENTRIES)
+#define SQFS_BLOCK_SIZE(A) ((A) & GENMASK(23, 0))
+#define SQFS_CHECK_FLAG(flag, bit) (((flag) >> (bit)) & 1)
+/* Useful for both fragment and data blocks */
+#define SQFS_COMPRESSED_BLOCK(A) (!((A) & BIT(24)))
+/* SQFS_COMPRESSED_DATA strictly used with super block's 'flags' member */
+#define SQFS_COMPRESSED_DATA(A) (!((A) & 0x0002))
+#define SQFS_IS_FRAGMENTED(A) ((A) != 0xFFFFFFFF)
+/*
+ * These two macros work as getters for a metada block header, retrieving the
+ * data size and if it is compressed/uncompressed
+ */
+#define SQFS_COMPRESSED_METADATA(A) (!((A) & BIT(15)))
+#define SQFS_METADATA_SIZE(A) ((A) & GENMASK(14, 0))
+
+struct squashfs_super_block_flags {
+	/* check: unused
+	 * uncompressed_ids: not supported
+	 */
+	bool uncompressed_inodes;
+	bool uncompressed_data;
+	bool check;
+	bool uncompressed_frags;
+	bool no_frags;
+	bool always_frags;
+	bool duplicates;
+	bool exportable;
+	bool uncompressed_xattrs;
+	bool no_xattrs;
+	bool compressor_options;
+	bool uncompressed_ids;
+};
+
+#endif /* SQFS_UTILS_H  */
diff --git a/include/configs/imx8mp_evk.h b/include/configs/imx8mp_evk.h
index a89d161122..32b69eadd2 100644
--- a/include/configs/imx8mp_evk.h
+++ b/include/configs/imx8mp_evk.h
@@ -11,6 +11,19 @@
 
 #include "imx_env.h"
 
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 for MicroSD(1), USDHC3 for EMMC(2) */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p1"  /* USDHC2 */
+
+#ifdef  CONFIG_SYS_BOOTM_LEN
+#undef  CONFIG_SYS_BOOTM_LEN
+#endif
+#define CONFIG_SYS_BOOTM_LEN		(SZ_256M + SZ_128M)
+
+/* Size of malloc() pool */
+#ifdef CONFIG_SYS_MALLOC_LEN
+#undef CONFIG_SYS_MALLOC_LEN
+#endif
+#define CONFIG_SYS_MALLOC_LEN		SZ_128M
 
 #define CONFIG_SPL_MAX_SIZE		(152 * 1024)
 #define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
@@ -103,14 +116,16 @@
 #define CONFIG_EXTRA_ENV_SETTINGS		\
 	CONFIG_MFG_ENV_SETTINGS \
 	JAILHOUSE_ENV \
-	"script=boot.scr\0" \
-	"image=Image\0" \
+	"loadprefix=/boot/\0" \
+	"script=/boot/boot.scr\0" \
+	"image=/boot/fitImage-initramfs.bin\0" \
 	"splashimage=0x50000000\0" \
 	"console=ttymxc1,115200\0" \
 	"fdt_addr=0x43000000\0"			\
 	"fdt_high=0xffffffffffffffff\0"		\
-	"boot_fit=no\0" \
-	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"boot_fit=try\0" \
+	"bootpart=1\0" \
+	"fdt_file=/boot/" CONFIG_DEFAULT_FDT_FILE "\0" \
 	"initrd_addr=0x43800000\0"		\
 	"initrd_high=0xffffffffffffffff\0" \
 	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
@@ -118,11 +133,11 @@
 	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
 	"mmcautodetect=yes\0" \
 	"mmcargs=setenv bootargs ${jh_clk} console=${console} root=${mmcroot}\0 " \
-	"loadbootscript=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"loadbootscript=ext4load mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
 	"bootscript=echo Running bootscript from mmc ...; " \
 		"source\0" \
-	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
-	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"loadimage=ext4load mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=ext4load mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
 	"mmcboot=echo Booting from mmc ...; " \
 		"run mmcargs; " \
 		"if test ${boot_fit} = yes || test ${boot_fit} = try; then " \
@@ -169,7 +184,7 @@
 #endif
 
 /* Link Definitions */
-#define CONFIG_LOADADDR			0x40480000
+#define CONFIG_LOADADDR			0x43800000
 
 #define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
 
@@ -186,12 +201,6 @@
 #define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
 #define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
 
-#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
-#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
-
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		SZ_32M
-
 /* Totally 6GB DDR */
 #define CONFIG_SYS_SDRAM_BASE		0x40000000
 #define PHYS_SDRAM			0x40000000
diff --git a/include/configs/srg-im8p.h b/include/configs/srg-im8p.h
new file mode 100644
index 0000000000..58dd9537b8
--- /dev/null
+++ b/include/configs/srg-im8p.h
@@ -0,0 +1,315 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 UWINGS
+ *
+ * Copyright 2019 NXP
+ */
+
+#ifndef __SRG_IM8P_H
+#define __SRG_IM8P_H
+
+#include <linux/sizes.h>
+#include <asm/arch/imx-regs.h>
+
+#include "imx_env.h"
+
+#define CONFIG_SYS_MMC_ENV_DEV		2   /* USDHC2 for MicroSD(1), USDHC3 for EMMC(2) */
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* EMMC */
+
+#ifdef  CONFIG_SYS_BOOTM_LEN
+#undef  CONFIG_SYS_BOOTM_LEN
+#endif
+
+#ifndef SZ_384M
+#define SZ_384M				(SZ_256M + SZ_128M)
+#endif
+
+#define CONFIG_SYS_BOOTM_LEN		SZ_384M
+
+/* Size of malloc() pool */
+#ifdef CONFIG_SYS_MALLOC_LEN
+#undef CONFIG_SYS_MALLOC_LEN
+#endif
+#define CONFIG_SYS_MALLOC_LEN		SZ_128M
+
+#define CONFIG_SPL_MAX_SIZE		(152 * 1024)
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR	0x300
+#define CONFIG_SYS_MMCSD_FS_BOOT_PARTITION	1
+#define CONFIG_SYS_UBOOT_BASE	(QSPI0_AMBA_BASE + CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR * 512)
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_STACK		0x187FF0
+#define CONFIG_SPL_BSS_START_ADDR      0x0095e000
+#define CONFIG_SPL_BSS_MAX_SIZE        0x2000	/* 8 KB */
+#define CONFIG_SYS_SPL_MALLOC_START    0x42200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE     SZ_512K	/* 512 KB */
+
+#define CONFIG_MALLOC_F_ADDR		0x184000 /* malloc f used before GD_FLG_FULL_MALLOC_INIT set */
+
+#define CONFIG_SPL_ABORT_ON_RAW_IMAGE
+
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PCA9450
+
+#define CONFIG_SYS_I2C
+
+#endif
+
+#define CONFIG_CMD_READ
+#define CONFIG_SERIAL_TAG
+#define CONFIG_FASTBOOT_USB_DEV 0
+
+#define CONFIG_REMAKE_ELF
+/* ENET Config */
+/* ENET1 */
+#if defined(CONFIG_CMD_NET)
+#define CONFIG_ETHPRIME                 "eth1" /* Set eqos to primary since we use its MDIO */
+
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_FEC_MXC_PHYADDR          1
+#define FEC_QUIRK_ENET_MAC
+
+#define DWC_NET_PHYADDR			1
+#ifdef CONFIG_DWC_ETH_QOS
+#define CONFIG_SYS_NONCACHED_MEMORY     (1 * SZ_1M)     /* 1M */
+#endif
+
+#define PHY_ANEG_TIMEOUT 20000
+#define CONFIG_NET_RANDOM_ETHADDR
+//#define CONFIG_RTL8211F_PHY_FORCE_EEE_RXC_ON
+#endif
+#define BOOTENV_DEV_LEGACY_MMC(devtypeu, devtypel, instance) \
+	"bootcmd_" #devtypel #instance "=" \
+	"setenv mmcdev " #instance"; " \
+	"setenv mmcroot /dev/mmcblk" #instance"p${bootpart} rootwait rw; " \
+	"if run loadbootscript; then " \
+		"run bootscript; " \
+	"else " \
+		"if run loadimage; then " \
+			"run mmcboot; " \
+		"fi; " \
+	"fi;\0"
+
+#define BOOTENV_DEV_NAME_LEGACY_MMC(devtypeu, devtypel, instance) \
+	#devtypel #instance " "
+
+#ifdef CONFIG_DISTRO_DEFAULTS
+#define BOOT_TARGET_DEVICES(func) \
+	func(USB, usb, 0) \
+	func(MMC, mmc, 1) \
+	func(LEGACY_MMC, legacy_mmc, 1) \
+	func(MMC, mmc, 2) \
+	func(LEGACY_MMC, legacy_mmc, 2) \
+
+
+#include <config_distro_bootcmd.h>
+#else
+#define BOOTENV
+#endif
+
+#define JAILHOUSE_ENV \
+	"jh_clk= \0 " \
+	"jh_mmcboot=setenv fdt_file srg-im8p-root.dtb;;" \
+		"setenv jh_clk clk_ignore_unused; mem=2048MB;" \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run jh_netboot; fi; \0" \
+	"jh_netboot=setenv fdt_file srg-im8p-root.dtb;; setenv jh_clk clk_ignore_unused; mem=2048MB; run netboot; \0 "
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS_DEFAULT \
+	"initrd_addr=0x43800000\0" \
+	"initrd_high=0xffffffffffffffff\0" \
+	"emmc_dev=2\0"\
+	"sd_dev=1\0" \
+
+/* Initial environment variables */
+#define FALLBACK_BOOTCOUNT_ENV \
+	"bootlimit=4\0" \
+	"bootfallback=echo Fallback to previous RootFS; " \
+		"if test ${bootpart} = 2; then " \
+		"	setenv bootpart 3; " \
+		"else " \
+		"	setenv bootpart 2; " \
+		"fi; " \
+		"setenv mmcroot /dev/mmcblk2p${bootpart} rootwait rw; " \
+		"setenv upgrade_available 0; setenv bootcount 0; saveenv;\0" \
+	"altbootcmd=run bootballback; " \
+		"run bootcmd;\0" \
+
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	CONFIG_MFG_ENV_SETTINGS \
+	JAILHOUSE_ENV \
+	FALLBACK_BOOTCOUNT_ENV \
+	BOOTENV \
+	"env_on_emmc=y\0" \
+	"script=/boot/boot.scr\0" \
+	"kernel_addr_r=" __stringify(CONFIG_LOADADDR) "\0" \
+	"bsp_script=/boot/boot.scr\0" \
+	"image=/boot/Image\0" \
+	"splashimage=0x50000000\0" \
+	"console=ttymxc1,115200\0" \
+	"fdt_addr_r=0x43000000\0"			\
+	"fdt_addr=0x43000000\0"			\
+	"boot_fdt=try\0" \
+	"bootpart=2\0" \
+	"fdt_high=0xffffffffffffffff\0"		\
+	"boot_fit=no\0" \
+	"fdtfile=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"bootm_size=0x10000000\0" \
+	"initrd_addr=0x43800000\0"		\
+	"initrd_addr_r=0x43800000\0"		\
+	"initrd_high=0xffffffffffffffff\0" \
+	"initrdfile=/boot/initrd.img\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=no\0" \
+	"mmcargs=setenv bootargs ${jh_clk} ${datawipe} ${bootopts} "\
+		"console=${console} root=${mmcroot}\0 " \
+	"loadbootscript=ext4load mmc ${mmcdev}:${bootpart} ${loadaddr} ${bsp_script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=ext4load mmc ${mmcdev}:${bootpart} ${loadaddr} ${image}\0" \
+	"loadfdt=ext4load mmc ${mmcdev}:${bootpart} ${fdt_addr_r} ${fdtfile}\0" \
+	"loadinitrd=ext4load mmc ${mmcdev}:${bootpart} ${initrd_addr_r} ${initrdfile}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fit} = yes || test ${boot_fit} = try; then " \
+			"bootm ${loadaddr}; " \
+		"else " \
+			"if run loadfdt; then " \
+				"if run loadinitrd; then " \
+					"echo booting with initramfs; " \
+					"booti ${loadaddr} ${initrd_addr_r} ${fdt_addr_r}; " \
+				"else " \
+					"booti ${loadaddr} - ${fdt_addr_r}; " \
+				"fi; " \
+			"else " \
+				"echo WARN: Cannot load the DT; " \
+			"fi; " \
+		"fi;\0" \
+	"usbargs=setenv bootargs ${jh_clk} ${datawipe} ${bootopts} console=${console} " \
+		"root=/dev/sda rootwait rw\0" \
+	"usbboot=echo Booting from USB ...; " \
+	"netargs=setenv bootargs ${jh_clk} console=${console} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs;  " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${loadaddr} ${image}; " \
+		"if test ${boot_fit} = yes || test ${boot_fit} = try; then " \
+			"bootm ${loadaddr}; " \
+		"else " \
+			"if ${get_cmd} ${fdt_addr_r} ${fdtfile}; then " \
+				"booti ${loadaddr} - ${fdt_addr_r}; " \
+			"else " \
+				"echo WARN: Cannot load the DT; " \
+			"fi; " \
+		"fi;\0" \
+	"bsp_bootcmd=echo Running BSP bootcmd ...; " \
+		"mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "fi;"
+
+/* Link Definitions */
+#define CONFIG_LOADADDR			0x40480000
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+
+#define CONFIG_SYS_INIT_RAM_ADDR	0x40000000
+#define CONFIG_SYS_INIT_RAM_SIZE	0x80000
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+
+/* Totally 2GB DDR */
+#define CONFIG_SYS_SDRAM_BASE		0x40000000
+#define PHYS_SDRAM			0x40000000
+#define PHYS_SDRAM_SIZE			0x80000000	/* 2 GB */
+
+#define CONFIG_SYS_MEMTEST_START	0x60000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + \
+					(PHYS_SDRAM_SIZE >> 1))
+
+#define CONFIG_MXC_UART_BASE		UART2_BASE_ADDR
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_CBSIZE		2048
+#define CONFIG_SYS_MAXARGS		64
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+
+#define CONFIG_IMX_BOOTAUX
+#define CONFIG_FSL_USDHC
+
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+#ifdef CONFIG_FSL_FSPI
+#define FSL_FSPI_FLASH_SIZE		SZ_32M
+#define FSL_FSPI_FLASH_NUM		1
+#define FSPI0_BASE_ADDR			0x30bb0000
+#define FSPI0_AMBA_BASE			0x0
+#define CONFIG_FSPI_QUAD_SUPPORT
+
+#define CONFIG_SYS_FSL_FSPI_AHB
+#endif
+
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* USB configs */
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_GADGET_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#else
+#undef CONFIG_CMD_USB
+#undef CONFIG_USB_STORAGE
+#undef CONFIG_CMD_USB_MASS_STORAGE
+#undef CONFIG_USB_GADGET_MASS_STORAGE
+#undef CONFIG_USB_FUNCTION_MASS_STORAGE
+#endif
+
+#define CONFIG_USB_MAX_CONTROLLER_COUNT         2
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_VBUS_DRAW 2
+
+#ifdef CONFIG_DM_VIDEO
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_BMP_24BPP
+#define CONFIG_BMP_32BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+#endif
diff --git a/include/fs.h b/include/fs.h
index 9cd3b3f106..13240e8a7b 100644
--- a/include/fs.h
+++ b/include/fs.h
@@ -13,6 +13,7 @@
 #define FS_TYPE_SANDBOX	3
 #define FS_TYPE_UBIFS	4
 #define FS_TYPE_BTRFS	5
+#define FS_TYPE_SQUASHFS 6
 
 int do_fat_size(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[]);
 
diff --git a/include/mmc.h b/include/mmc.h
index 59570995a1..c597a76b64 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -178,6 +178,7 @@ static inline bool mmc_is_tuning_cmd(uint cmdidx)
 #define MMC_STATUS_ERROR	(1 << 19)
 
 #define MMC_STATE_PRG		(7 << 9)
+#define MMC_STATE_TRANS		(4 << 9)
 
 #define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
@@ -224,7 +225,9 @@ static inline bool mmc_is_tuning_cmd(uint cmdidx)
 #define EXT_CSD_WR_REL_PARAM		166	/* R */
 #define EXT_CSD_WR_REL_SET		167	/* R/W */
 #define EXT_CSD_RPMB_MULT		168	/* RO */
+#define EXT_CSD_USER_WP			171	/* R/W & R/W/C_P & R/W/E_P */
 #define EXT_CSD_BOOT_WP			173	/* R/W & R/W/C_P */
+#define EXT_CSD_BOOT_WP_STATUS		174	/* R */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
 #define EXT_CSD_BOOT_BUS_WIDTH		177
 #define EXT_CSD_PART_CONF		179	/* R/W */
@@ -945,6 +948,26 @@ int mmc_map_to_kernel_blk(int dev_no);
  */
 struct blk_desc *mmc_get_blk_desc(struct mmc *mmc);
 
+/**
+ * mmc_send_ext_csd() - read the extended CSD register
+ *
+ * @mmc:	MMC device
+ * @ext_csd	a cache aligned buffer of length MMC_MAX_BLOCK_LEN allocated by
+ *		the caller, e.g. using
+ *		ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN)
+ * Return:	0 for success
+ */
+int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd);
+
+/**
+ * mmc_boot_wp() - power on write protect boot partitions
+ *
+ * The boot partitions are write protected until the next power cycle.
+ *
+ * Return:	0 for success
+ */
+int mmc_boot_wp(struct mmc *mmc);
+
 static inline enum dma_data_direction mmc_get_dma_dir(struct mmc_data *data)
 {
 	return data->flags & MMC_DATA_WRITE ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
diff --git a/include/squashfs.h b/include/squashfs.h
new file mode 100644
index 0000000000..37ba5da75b
--- /dev/null
+++ b/include/squashfs.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ *
+ * squashfs.h: SquashFS filesystem implementation.
+ */
+
+#ifndef _SQFS_H_
+#define _SQFS_H_
+
+int sqfs_opendir(const char *filename, struct fs_dir_stream **dirsp);
+int sqfs_readdir(struct fs_dir_stream *dirs, struct fs_dirent **dentp);
+int sqfs_probe(struct blk_desc *fs_dev_desc,
+	       disk_partition_t *fs_partition);
+int sqfs_read(const char *filename, void *buf, loff_t offset,
+	      loff_t len, loff_t *actread);
+int sqfs_size(const char *filename, loff_t *size);
+int sqfs_exists(const char *filename);
+void sqfs_close(void);
+void sqfs_closedir(struct fs_dir_stream *dirs);
+
+#endif /* SQFS_H  */
diff --git a/include/u-boot/zlib.h b/include/u-boot/zlib.h
index e23ceb50ca..a33cc8780d 100644
--- a/include/u-boot/zlib.h
+++ b/include/u-boot/zlib.h
@@ -110,6 +110,12 @@ extern "C" {
 #  define voidp                 z_voidp
 #endif
 
+#if defined(ZLIB_CONST) && !defined(z_const)
+#  define z_const const
+#else
+#  define z_const
+#endif
+
 #if defined(__MSDOS__) && !defined(MSDOS)
 #  define MSDOS
 #endif
@@ -710,6 +716,32 @@ ZEXTERN  uInt ZEXPORT crc32  OF((uInt crc, const Bytef *buf, uInt len));
      if (crc != original_crc) error();
 */
 
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest, uLongf *destLen,
+				   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer.  Upon entry, destLen is the total size
+   of the destination buffer, which must be large enough to hold the entire
+   uncompressed data.  (The size of the uncompressed data must have been saved
+   previously by the compressor and transmitted to the decompressor by some
+   mechanism outside the scope of this compression library.) Upon exit, destLen
+   is the actual size of the uncompressed data.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
+   the case where there is not enough room, uncompress() will fill the output
+   buffer with the uncompressed data up to that point.
+*/
+
+ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest, uLongf *destLen,
+				    const Bytef *source, uLong *sourceLen));
+/*
+     Same as uncompress, except that sourceLen is a pointer, where the
+   length of the source is *sourceLen.  On return, *sourceLen is the number of
+   source bytes consumed.
+*/
+
 ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                       const char *version, int stream_size));
 #define inflateInit(strm) \
diff --git a/lib/Kconfig b/lib/Kconfig
index c43149fc1a..7ae7bbf334 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -441,6 +441,12 @@ config GZIP
 	help
 	  This enables support for GZIP compression algorithm.
 
+config ZLIB_UNCOMPRESS
+	bool "Enables zlib's uncompress() functionality"
+	help
+	  This enables an extra zlib functionality: the uncompress() function,
+	  which decompresses data from a buffer into another, knowing their
+	  sizes. Unlike gunzip(), there is no header parsing.
 config ZLIB
 	bool
 	default y
diff --git a/lib/zlib/inftrees.c b/lib/zlib/inftrees.c
index b71b9695a8..caee502f88 100644
--- a/lib/zlib/inftrees.c
+++ b/lib/zlib/inftrees.c
@@ -50,7 +50,7 @@ int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
     code FAR *next;             /* next available space in table */
     const unsigned short FAR *base;     /* base value table to use */
     const unsigned short FAR *extra;    /* extra bits table to use */
-    int end;                    /* use base and extra for symbol > end */
+    unsigned match;             /* use base and extra for symbol >= match */
     unsigned short count[MAXBITS+1];    /* number of codes of each length */
     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
@@ -178,19 +178,17 @@ int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
     switch (type) {
     case CODES:
         base = extra = work;    /* dummy value--not used */
-        end = 19;
+        match = 20;
         break;
     case LENS:
         base = lbase;
-        base -= 257;
         extra = lext;
-        extra -= 257;
-        end = 256;
+        match = 257;
         break;
     default:            /* DISTS */
         base = dbase;
         extra = dext;
-        end = -1;
+        match = 0;
     }
 
     /* initialize state for loop */
@@ -212,13 +210,12 @@ int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
     for (;;) {
         /* create table entry */
         this.bits = (unsigned char)(len - drop);
-        if ((int)(work[sym]) < end) {
+        if (work[sym] + 1 < match) {
             this.op = (unsigned char)0;
             this.val = work[sym];
-        }
-        else if ((int)(work[sym]) > end) {
-            this.op = (unsigned char)(extra[work[sym]]);
-            this.val = base[work[sym]];
+        } else if (work[sym] >= match) {
+            this.op = (unsigned char)(extra[work[sym] - match]);
+            this.val = base[work[sym] - match];
         }
         else {
             this.op = (unsigned char)(32 + 64);         /* end of block */
diff --git a/lib/zlib/uncompr.c b/lib/zlib/uncompr.c
new file mode 100644
index 0000000000..21e93933b2
--- /dev/null
+++ b/lib/zlib/uncompr.c
@@ -0,0 +1,97 @@
+/* uncompr.c -- decompress a memory buffer
+ * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#define ZLIB_INTERNAL
+#include "zlib.h"
+
+/* ===========================================================================
+     Decompresses the source buffer into the destination buffer.  *sourceLen is
+   the byte length of the source buffer. Upon entry, *destLen is the total size
+   of the destination buffer, which must be large enough to hold the entire
+   uncompressed data. (The size of the uncompressed data must have been saved
+   previously by the compressor and transmitted to the decompressor by some
+   mechanism outside the scope of this compression library.) Upon exit,
+   *destLen is the size of the decompressed data and *sourceLen is the number
+   of source bytes consumed. Upon return, source + *sourceLen points to the
+   first unused input byte.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or
+   Z_DATA_ERROR if the input data was corrupted, including if the input data is
+   an incomplete zlib stream.
+*/
+int ZEXPORT uncompress2(dest, destLen, source, sourceLen)
+	Bytef *dest;
+	uLongf *destLen;
+	const Bytef *source;
+	uLong *sourceLen;
+
+{
+	z_stream stream;
+	int err;
+	const uInt max = (uInt)-1;
+	uLong len, left;
+	/* for detection of incomplete stream when *destLen == 0 */
+	Byte buf[1];
+
+	len = *sourceLen;
+	if (*destLen) {
+		left = *destLen;
+		*destLen = 0;
+	} else {
+		left = 1;
+		dest = buf;
+	}
+
+	stream.next_in = (z_const Bytef *)source;
+	stream.avail_in = 0;
+	stream.zalloc = (alloc_func)0;
+	stream.zfree = (free_func)0;
+	stream.opaque = (voidpf)0;
+
+	err = inflateInit(&stream);
+	if (err != Z_OK)
+		return err;
+
+	stream.next_out = dest;
+	stream.avail_out = 0;
+
+	do {
+		if (stream.avail_out == 0) {
+			stream.avail_out = left > (uLong)max ? max : (uInt)left;
+			left -= stream.avail_out;
+		}
+
+		if (stream.avail_in == 0) {
+			stream.avail_in = len > (uLong)max ? max : (uInt)len;
+			len -= stream.avail_in;
+		}
+
+		err = inflate(&stream, Z_NO_FLUSH);
+	} while (err == Z_OK);
+
+	*sourceLen -= len + stream.avail_in;
+	if (dest != buf)
+		*destLen = stream.total_out;
+	else if (stream.total_out && err == Z_BUF_ERROR)
+		left = 1;
+
+	inflateEnd(&stream);
+	return err == Z_STREAM_END ? Z_OK :
+		err == Z_NEED_DICT ? Z_DATA_ERROR  :
+		err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
+		err;
+}
+
+int ZEXPORT uncompress(dest, destLen, source, sourceLen)
+	Bytef *dest;
+	uLongf *destLen;
+	const Bytef *source;
+	uLong sourceLen;
+{
+	return uncompress2(dest, destLen, source, &sourceLen);
+}
diff --git a/lib/zlib/zlib.c b/lib/zlib/zlib.c
index 7e1570292c..90e05e7d4d 100644
--- a/lib/zlib/zlib.c
+++ b/lib/zlib/zlib.c
@@ -30,3 +30,6 @@
 #include "inflate.c"
 #include "zutil.c"
 #include "adler32.c"
+#if IS_ENABLED(CONFIG_ZLIB_UNCOMPRESS)
+#include "uncompr.c"
+#endif
-- 
2.33.0

